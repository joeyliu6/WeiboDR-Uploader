# PicNexus æ—¶é—´è½´åŠŸèƒ½å¼€å‘æ–‡æ¡£

> ä¸º PicNexus æ·»åŠ ç±»ä¼¼ Google ç›¸å†Œçš„æ—¶é—´è½´æµè§ˆåŠŸèƒ½

---

## ç›®å½•

1. [åŠŸèƒ½æ¦‚è¿°](#1-åŠŸèƒ½æ¦‚è¿°)
2. [è®¾è®¡å‚è€ƒ](#2-è®¾è®¡å‚è€ƒ)
3. [æŠ€æœ¯æ¶æ„](#3-æŠ€æœ¯æ¶æ„)
4. [æ•°æ®æ¨¡å‹è®¾è®¡](#4-æ•°æ®æ¨¡å‹è®¾è®¡)
5. [ç»„ä»¶è®¾è®¡](#5-ç»„ä»¶è®¾è®¡)
6. [å®ç°æ­¥éª¤](#6-å®ç°æ­¥éª¤)
7. [æ ¸å¿ƒä»£ç ç¤ºä¾‹](#7-æ ¸å¿ƒä»£ç ç¤ºä¾‹)
8. [æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
9. [æµ‹è¯•è¦ç‚¹](#9-æµ‹è¯•è¦ç‚¹)

---

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 ç›®æ ‡

åœ¨ç°æœ‰å†å²è®°å½•åŠŸèƒ½åŸºç¡€ä¸Šï¼Œæ·»åŠ æ—¶é—´è½´è§†å›¾ï¼Œè®©ç”¨æˆ·èƒ½å¤Ÿï¼š

- æŒ‰æ—¶é—´ï¼ˆå¹´/æœˆ/æ—¥ï¼‰æµè§ˆä¸Šä¼ çš„å›¾ç‰‡
- å¿«é€Ÿå®šä½åˆ°ç‰¹å®šæ—¶é—´æ®µ
- æµç•…æ»šåŠ¨æŸ¥çœ‹å¤§é‡å›¾ç‰‡
- æ”¯æŒå›¾ç‰‡é¢„è§ˆå’Œæ‰¹é‡æ“ä½œ

### 1.2 æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | æè¿° |
|------|------|
| **æ—¶é—´åˆ†ç»„** | æŒ‰æ—¥æœŸè‡ªåŠ¨åˆ†ç»„ï¼Œæ˜¾ç¤ºã€Œ2024å¹´1æœˆã€ã€Œä»Šå¤©ã€ã€Œæ˜¨å¤©ã€ç­‰æ ‡ç­¾ |
| **è™šæ‹Ÿæ»šåŠ¨** | æ”¯æŒæ•°åƒå¼ å›¾ç‰‡æµç•…æ»šåŠ¨ï¼Œæ— æ€§èƒ½é—®é¢˜ |
| **å¿«é€Ÿå¯¼èˆª** | å³ä¾§æ—¶é—´è½´æ»‘å—ï¼Œæ‹–åŠ¨å¿«é€Ÿè·³è½¬ |
| **å“åº”å¼ç½‘æ ¼** | æ ¹æ®çª—å£å®½åº¦è‡ªåŠ¨è°ƒæ•´æ¯è¡Œå›¾ç‰‡æ•°é‡ |
| **æ‡’åŠ è½½** | ä»…åŠ è½½å¯è§åŒºåŸŸçš„å›¾ç‰‡ç¼©ç•¥å›¾ |
| **å¤šé€‰æ“ä½œ** | æ”¯æŒ Shift/Ctrl å¤šé€‰ï¼Œæ‰¹é‡å¤åˆ¶é“¾æ¥æˆ–åˆ é™¤ |

---

## 2. è®¾è®¡å‚è€ƒ

### 2.1 Google ç›¸å†Œæ—¶é—´è½´ç‰¹ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â† è¿”å›    æ—¶é—´è½´                           ğŸ” ç­›é€‰     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â–²    â”‚
â”‚  2024å¹´1æœˆ15æ—¥ Â· ä»Šå¤©                              â”‚    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                  â”‚    â”‚
â”‚  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚                  â”‚    â”‚
â”‚  â”‚img1â”‚img2â”‚img3â”‚img4â”‚img5â”‚img6â”‚                  2024  â”‚
â”‚  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                  â”‚    â”‚
â”‚                                                    â”‚    â”‚
â”‚  2024å¹´1æœˆ14æ—¥ Â· æ˜¨å¤©                              â”‚    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                            â”‚    â”‚
â”‚  â”‚    â”‚    â”‚    â”‚    â”‚                            â”‚    â”‚
â”‚  â”‚img7â”‚img8â”‚img9â”‚i10 â”‚                            â”‚    â”‚
â”‚  â”‚    â”‚    â”‚    â”‚    â”‚                            â–¼    â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                                 â”‚
â”‚                                                         â”‚
â”‚  2024å¹´1æœˆ10æ—¥                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                                           â”‚
â”‚  â”‚    â”‚    â”‚                                           â”‚
â”‚  â”‚i11 â”‚i12 â”‚                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 äº¤äº’è®¾è®¡è¦ç‚¹

1. **ç²˜æ€§æ—¥æœŸæ ‡é¢˜**ï¼šæ»šåŠ¨æ—¶å½“å‰æ—¥æœŸå›ºå®šåœ¨é¡¶éƒ¨
2. **å¹³æ»‘è¿‡æ¸¡**ï¼šæ—¥æœŸæ ‡é¢˜åˆ‡æ¢æ—¶æœ‰æ·¡å…¥æ·¡å‡ºæ•ˆæœ
3. **æ—¶é—´è½´æ»‘å—**ï¼š
   - æ˜¾ç¤ºå¹´ä»½åˆ»åº¦
   - æ‹–åŠ¨æ—¶æ˜¾ç¤ºå…·ä½“æ—¥æœŸé¢„è§ˆ
   - æ¾å¼€åå¹³æ»‘æ»šåŠ¨åˆ°ç›®æ ‡ä½ç½®
4. **å›¾ç‰‡æ‚¬åœæ•ˆæœ**ï¼šæ˜¾ç¤ºé€‰æ‹©æ¡†å’Œä¸Šä¼ ä¿¡æ¯

---

## 3. æŠ€æœ¯æ¶æ„

### 3.1 æŠ€æœ¯æ ˆé€‚é…

åŸºäº PicNexus ç°æœ‰æŠ€æœ¯æ ˆï¼š

| å±‚çº§ | æŠ€æœ¯ | ç”¨é€” |
|------|------|------|
| å‰ç«¯æ¡†æ¶ | Vue 3 + TypeScript | ç»„ä»¶å¼€å‘ |
| çŠ¶æ€ç®¡ç† | Piniaï¼ˆæ¨èï¼‰æˆ– Vue Composition API | ç®¡ç†å›¾ç‰‡æ•°æ®å’Œè§†å›¾çŠ¶æ€ |
| è™šæ‹Ÿæ»šåŠ¨ | `vue-virtual-scroller` æˆ–è‡ªå®ç° | å¤§é‡å›¾ç‰‡æ€§èƒ½ä¼˜åŒ– |
| åç«¯ | Tauri (Rust) | æ•°æ®åº“æ“ä½œã€æ–‡ä»¶ç³»ç»Ÿè®¿é—® |
| æ•°æ®åº“ | SQLiteï¼ˆé€šè¿‡ Tauriï¼‰ | å­˜å‚¨ä¸Šä¼ å†å² |
| æ ·å¼ | CSS/SCSS | å“åº”å¼å¸ƒå±€ |

### 3.2 ç›®å½•ç»“æ„å»ºè®®

```
src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ timeline/
â”‚       â”œâ”€â”€ TimelineView.vue          # ä¸»è§†å›¾å®¹å™¨
â”‚       â”œâ”€â”€ TimelineDateGroup.vue     # æ—¥æœŸåˆ†ç»„ç»„ä»¶
â”‚       â”œâ”€â”€ TimelineImageGrid.vue     # å›¾ç‰‡ç½‘æ ¼ç»„ä»¶
â”‚       â”œâ”€â”€ TimelineImage.vue         # å•ä¸ªå›¾ç‰‡ç»„ä»¶
â”‚       â”œâ”€â”€ TimelineScrubber.vue      # å³ä¾§æ—¶é—´è½´æ»‘å—
â”‚       â”œâ”€â”€ TimelineStickyHeader.vue  # ç²˜æ€§æ—¥æœŸæ ‡é¢˜
â”‚       â””â”€â”€ index.ts                  # å¯¼å‡º
â”œâ”€â”€ composables/
â”‚   â”œâ”€â”€ useTimelineData.ts            # æ•°æ®è·å–å’Œå¤„ç†
â”‚   â”œâ”€â”€ useVirtualScroll.ts           # è™šæ‹Ÿæ»šåŠ¨é€»è¾‘
â”‚   â”œâ”€â”€ useImageSelection.ts          # å›¾ç‰‡é€‰æ‹©é€»è¾‘
â”‚   â””â”€â”€ useTimelineNavigation.ts      # å¯¼èˆªé€»è¾‘
â”œâ”€â”€ stores/
â”‚   â””â”€â”€ timelineStore.ts              # Pinia store
â”œâ”€â”€ types/
â”‚   â””â”€â”€ timeline.ts                   # ç±»å‹å®šä¹‰
â””â”€â”€ utils/
    â””â”€â”€ dateUtils.ts                  # æ—¥æœŸå¤„ç†å·¥å…·
```

---

## 4. æ•°æ®æ¨¡å‹è®¾è®¡

### 4.1 TypeScript ç±»å‹å®šä¹‰

```typescript
// src/types/timeline.ts

/**
 * ä¸Šä¼ è®°å½•ï¼ˆå¯¹åº”æ•°æ®åº“è®°å½•ï¼‰
 */
export interface UploadRecord {
  id: string;                    // å”¯ä¸€æ ‡è¯†
  originalName: string;          // åŸå§‹æ–‡ä»¶å
  thumbnailPath: string;         // æœ¬åœ°ç¼©ç•¥å›¾è·¯å¾„
  uploadTime: number;            // ä¸Šä¼ æ—¶é—´æˆ³ (ms)
  fileSize: number;              // æ–‡ä»¶å¤§å° (bytes)
  width: number;                 // å›¾ç‰‡å®½åº¦
  height: number;                // å›¾ç‰‡é«˜åº¦
  
  // å„å›¾åºŠä¸Šä¼ ç»“æœ
  uploadResults: UploadResult[];
}

export interface UploadResult {
  platform: ImageHostPlatform;   // å›¾åºŠå¹³å°
  url: string;                   // å›¾ç‰‡é“¾æ¥
  success: boolean;              // æ˜¯å¦æˆåŠŸ
  uploadedAt: number;            // ä¸Šä¼ æ—¶é—´
}

export type ImageHostPlatform = 
  | 'tcl' 
  | 'jd' 
  | 'qiyu' 
  | 'weibo' 
  | 'zhihu' 
  | 'nowcoder' 
  | 'nami' 
  | 'r2';

/**
 * æŒ‰æ—¥æœŸåˆ†ç»„çš„æ•°æ®ç»“æ„
 */
export interface TimelineDateGroup {
  date: string;                  // æ—¥æœŸ keyï¼Œå¦‚ "2024-01-15"
  displayLabel: string;          // æ˜¾ç¤ºæ–‡æœ¬ï¼Œå¦‚ "ä»Šå¤©" / "2024å¹´1æœˆ15æ—¥"
  images: UploadRecord[];        // è¯¥æ—¥æœŸçš„å›¾ç‰‡åˆ—è¡¨
  height?: number;               // è®¡ç®—åçš„ç»„é«˜åº¦ï¼ˆç”¨äºè™šæ‹Ÿæ»šåŠ¨ï¼‰
}

/**
 * æ—¶é—´è½´è§†å›¾çŠ¶æ€
 */
export interface TimelineViewState {
  groups: TimelineDateGroup[];   // æ‰€æœ‰æ—¥æœŸåˆ†ç»„
  selectedIds: Set<string>;      // å·²é€‰ä¸­çš„å›¾ç‰‡ ID
  currentDate: string | null;    // å½“å‰å¯è§çš„æ—¥æœŸ
  isLoading: boolean;
  error: string | null;
  
  // è™šæ‹Ÿæ»šåŠ¨çŠ¶æ€
  scrollTop: number;
  visibleRange: {
    startIndex: number;
    endIndex: number;
  };
}

/**
 * æ—¶é—´è½´æ»‘å—æ•°æ®
 */
export interface ScrubberMark {
  date: string;                  // æ—¥æœŸ
  label: string;                 // æ˜¾ç¤ºæ ‡ç­¾ï¼ˆå¹´/æœˆï¼‰
  position: number;              // ä½ç½®ç™¾åˆ†æ¯” 0-100
  groupIndex: number;            // å¯¹åº”çš„åˆ†ç»„ç´¢å¼•
}
```

### 4.2 æ•°æ®åº“ Schema æ‰©å±•

å¦‚æœéœ€è¦æ‰©å±•ç°æœ‰æ•°æ®åº“ï¼Œå»ºè®®æ·»åŠ ç´¢å¼•ä¼˜åŒ–æ—¶é—´æŸ¥è¯¢ï¼š

```sql
-- ä¸ºä¸Šä¼ æ—¶é—´æ·»åŠ ç´¢å¼•ï¼ˆå¦‚æœå°šæœªå­˜åœ¨ï¼‰
CREATE INDEX IF NOT EXISTS idx_upload_time ON upload_history(upload_time DESC);

-- å¯é€‰ï¼šæ·»åŠ ç¼©ç•¥å›¾è·¯å¾„å­—æ®µ
ALTER TABLE upload_history ADD COLUMN thumbnail_path TEXT;
```

### 4.3 Rust åç«¯æ•°æ®ç»“æ„

```rust
// src-tauri/src/models/timeline.rs

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct UploadRecord {
    pub id: String,
    pub original_name: String,
    pub thumbnail_path: Option<String>,
    pub upload_time: i64,
    pub file_size: i64,
    pub width: u32,
    pub height: u32,
    pub upload_results: Vec<UploadResult>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UploadResult {
    pub platform: String,
    pub url: String,
    pub success: bool,
    pub uploaded_at: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TimelineQuery {
    pub start_date: Option<i64>,  // èµ·å§‹æ—¶é—´æˆ³
    pub end_date: Option<i64>,    // ç»“æŸæ—¶é—´æˆ³
    pub limit: Option<u32>,       // æ¯é¡µæ•°é‡
    pub offset: Option<u32>,      // åç§»é‡
}
```

---

## 5. ç»„ä»¶è®¾è®¡

### 5.1 ç»„ä»¶å±‚çº§ç»“æ„

```
TimelineView (ä¸»å®¹å™¨)
â”œâ”€â”€ TimelineStickyHeader (ç²˜æ€§æ—¥æœŸæ ‡é¢˜)
â”œâ”€â”€ VirtualScrollContainer (è™šæ‹Ÿæ»šåŠ¨å®¹å™¨)
â”‚   â””â”€â”€ TimelineDateGroup (æ—¥æœŸåˆ†ç»„) Ã— N
â”‚       â”œâ”€â”€ DateHeader (æ—¥æœŸæ ‡é¢˜)
â”‚       â””â”€â”€ TimelineImageGrid (å›¾ç‰‡ç½‘æ ¼)
â”‚           â””â”€â”€ TimelineImage (å›¾ç‰‡é¡¹) Ã— N
â””â”€â”€ TimelineScrubber (å³ä¾§æ—¶é—´è½´æ»‘å—)
```

### 5.2 ç»„ä»¶èŒè´£

| ç»„ä»¶ | èŒè´£ |
|------|------|
| `TimelineView` | æ•´ä½“å¸ƒå±€ã€æ•°æ®è·å–ã€åè°ƒå­ç»„ä»¶ |
| `TimelineStickyHeader` | å›ºå®šåœ¨é¡¶éƒ¨çš„æ—¥æœŸæ ‡é¢˜ï¼Œéšæ»šåŠ¨æ›´æ–° |
| `TimelineDateGroup` | å•ä¸ªæ—¥æœŸåˆ†ç»„çš„å®¹å™¨ |
| `TimelineImageGrid` | å“åº”å¼å›¾ç‰‡ç½‘æ ¼å¸ƒå±€ |
| `TimelineImage` | å•ä¸ªå›¾ç‰‡ï¼šç¼©ç•¥å›¾ã€é€‰æ‹©æ¡†ã€æ‚¬åœæ•ˆæœ |
| `TimelineScrubber` | å³ä¾§æ—¶é—´è½´å¿«é€Ÿå¯¼èˆªæ»‘å— |

### 5.3 ç»„ä»¶é€šä¿¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Pinia Store                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ state: groups, selectedIds, currentDate, etc.    â”‚  â”‚
â”‚  â”‚ actions: loadData, selectImage, scrollToDate     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜
                â”‚                                       â”‚
                â–¼                                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      TimelineView         â”‚       â”‚    TimelineScrubber       â”‚
â”‚  - è®¢é˜… store æ•°æ®        â”‚â—„â”€â”€â”€â”€â”€â–ºâ”‚  - æ˜¾ç¤ºæ—¶é—´è½´åˆ»åº¦         â”‚
â”‚  - æä¾›æ»šåŠ¨å®¹å™¨ ref       â”‚       â”‚  - æ‹–åŠ¨æ—¶ emit ç›®æ ‡æ—¥æœŸ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TimelineDateGroup       â”‚
â”‚  - æ¥æ”¶ group prop        â”‚
â”‚  - ç®¡ç†å†…éƒ¨å›¾ç‰‡æ¸²æŸ“       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     TimelineImage         â”‚
â”‚  - æ¥æ”¶ image prop        â”‚
â”‚  - emit select äº‹ä»¶       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. å®ç°æ­¥éª¤

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¡†æ¶ï¼ˆé¢„è®¡ 2-3 å¤©ï¼‰

- [ ] **Step 1**: åˆ›å»ºç±»å‹å®šä¹‰æ–‡ä»¶ `src/types/timeline.ts`
- [ ] **Step 2**: åˆ›å»º Pinia store `src/stores/timelineStore.ts`
- [ ] **Step 3**: å®ç°æ—¥æœŸå·¥å…·å‡½æ•° `src/utils/dateUtils.ts`
- [ ] **Step 4**: åˆ›å»ºåŸºç¡€ `TimelineView.vue` ç»„ä»¶
- [ ] **Step 5**: æ·»åŠ è·¯ç”±å’Œå¯¼èˆªå…¥å£

### é˜¶æ®µäºŒï¼šæ ¸å¿ƒç»„ä»¶ï¼ˆé¢„è®¡ 3-4 å¤©ï¼‰

- [ ] **Step 6**: å®ç° `TimelineDateGroup.vue`
- [ ] **Step 7**: å®ç° `TimelineImageGrid.vue` å“åº”å¼ç½‘æ ¼
- [ ] **Step 8**: å®ç° `TimelineImage.vue` å›¾ç‰‡ç»„ä»¶
- [ ] **Step 9**: å®ç°å›¾ç‰‡æ‡’åŠ è½½
- [ ] **Step 10**: æ·»åŠ å›¾ç‰‡é€‰æ‹©åŠŸèƒ½

### é˜¶æ®µä¸‰ï¼šé«˜çº§ç‰¹æ€§ï¼ˆé¢„è®¡ 3-4 å¤©ï¼‰

- [ ] **Step 11**: å®ç°è™šæ‹Ÿæ»šåŠ¨
- [ ] **Step 12**: å®ç° `TimelineStickyHeader.vue`
- [ ] **Step 13**: å®ç° `TimelineScrubber.vue` æ—¶é—´è½´æ»‘å—
- [ ] **Step 14**: æ·»åŠ æ‹–åŠ¨å¿«é€Ÿå¯¼èˆªåŠŸèƒ½

### é˜¶æ®µå››ï¼šä¼˜åŒ–å’Œå®Œå–„ï¼ˆé¢„è®¡ 2-3 å¤©ï¼‰

- [ ] **Step 15**: æ€§èƒ½ä¼˜åŒ–ï¼ˆé˜²æŠ–ã€èŠ‚æµã€ç¼“å­˜ï¼‰
- [ ] **Step 16**: æ·»åŠ åŠ è½½çŠ¶æ€å’Œé”™è¯¯å¤„ç†
- [ ] **Step 17**: å“åº”å¼é€‚é…ï¼ˆç§»åŠ¨ç«¯/æ¡Œé¢ç«¯ï¼‰
- [ ] **Step 18**: æ·»åŠ åŠ¨ç”»è¿‡æ¸¡æ•ˆæœ
- [ ] **Step 19**: æµ‹è¯•å’Œ Bug ä¿®å¤

---

## 7. æ ¸å¿ƒä»£ç ç¤ºä¾‹

### 7.1 Pinia Store

```typescript
// src/stores/timelineStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { invoke } from '@tauri-apps/api/tauri';
import type { UploadRecord, TimelineDateGroup, TimelineViewState } from '@/types/timeline';
import { groupByDate, formatDateLabel } from '@/utils/dateUtils';

export const useTimelineStore = defineStore('timeline', () => {
  // State
  const records = ref<UploadRecord[]>([]);
  const selectedIds = ref<Set<string>>(new Set());
  const currentDate = ref<string | null>(null);
  const isLoading = ref(false);
  const error = ref<string | null>(null);

  // Getters
  const groups = computed<TimelineDateGroup[]>(() => {
    const grouped = groupByDate(records.value);
    return Object.entries(grouped)
      .sort(([a], [b]) => b.localeCompare(a)) // é™åºæ’åˆ—
      .map(([date, images]) => ({
        date,
        displayLabel: formatDateLabel(date),
        images,
      }));
  });

  const selectedCount = computed(() => selectedIds.value.size);

  const selectedImages = computed(() => 
    records.value.filter(r => selectedIds.value.has(r.id))
  );

  // Actions
  async function loadRecords(query?: { startDate?: number; endDate?: number }) {
    isLoading.value = true;
    error.value = null;
    
    try {
      const data = await invoke<UploadRecord[]>('get_upload_history', { query });
      records.value = data;
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'åŠ è½½å¤±è´¥';
      console.error('Failed to load timeline data:', e);
    } finally {
      isLoading.value = false;
    }
  }

  function selectImage(id: string, multiSelect = false) {
    if (multiSelect) {
      if (selectedIds.value.has(id)) {
        selectedIds.value.delete(id);
      } else {
        selectedIds.value.add(id);
      }
    } else {
      selectedIds.value.clear();
      selectedIds.value.add(id);
    }
  }

  function selectRange(startId: string, endId: string) {
    const startIndex = records.value.findIndex(r => r.id === startId);
    const endIndex = records.value.findIndex(r => r.id === endId);
    
    if (startIndex === -1 || endIndex === -1) return;
    
    const [from, to] = startIndex < endIndex 
      ? [startIndex, endIndex] 
      : [endIndex, startIndex];
    
    for (let i = from; i <= to; i++) {
      selectedIds.value.add(records.value[i].id);
    }
  }

  function clearSelection() {
    selectedIds.value.clear();
  }

  function selectAll() {
    records.value.forEach(r => selectedIds.value.add(r.id));
  }

  function setCurrentDate(date: string | null) {
    currentDate.value = date;
  }

  return {
    // State
    records,
    selectedIds,
    currentDate,
    isLoading,
    error,
    // Getters
    groups,
    selectedCount,
    selectedImages,
    // Actions
    loadRecords,
    selectImage,
    selectRange,
    clearSelection,
    selectAll,
    setCurrentDate,
  };
});
```

### 7.2 æ—¥æœŸå·¥å…·å‡½æ•°

```typescript
// src/utils/dateUtils.ts

import type { UploadRecord } from '@/types/timeline';

/**
 * å°†æ—¶é—´æˆ³è½¬æ¢ä¸ºæ—¥æœŸ key
 */
export function timestampToDateKey(timestamp: number): string {
  const date = new Date(timestamp);
  return date.toISOString().split('T')[0]; // "2024-01-15"
}

/**
 * æŒ‰æ—¥æœŸåˆ†ç»„
 */
export function groupByDate(records: UploadRecord[]): Record<string, UploadRecord[]> {
  return records.reduce((groups, record) => {
    const dateKey = timestampToDateKey(record.uploadTime);
    if (!groups[dateKey]) {
      groups[dateKey] = [];
    }
    groups[dateKey].push(record);
    return groups;
  }, {} as Record<string, UploadRecord[]>);
}

/**
 * æ ¼å¼åŒ–æ—¥æœŸæ ‡ç­¾
 */
export function formatDateLabel(dateKey: string): string {
  const date = new Date(dateKey);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
  const target = new Date(date.getFullYear(), date.getMonth(), date.getDate());

  if (target.getTime() === today.getTime()) {
    return 'ä»Šå¤©';
  }
  if (target.getTime() === yesterday.getTime()) {
    return 'æ˜¨å¤©';
  }
  
  const isThisYear = date.getFullYear() === now.getFullYear();
  
  if (isThisYear) {
    return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
  }
  
  return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
}

/**
 * è·å–ç›¸å¯¹æ—¶é—´æè¿°
 */
export function getRelativeTime(timestamp: number): string {
  const diff = Date.now() - timestamp;
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);

  if (minutes < 1) return 'åˆšåˆš';
  if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;
  if (hours < 24) return `${hours}å°æ—¶å‰`;
  if (days < 7) return `${days}å¤©å‰`;
  
  return formatDateLabel(timestampToDateKey(timestamp));
}

/**
 * ç”Ÿæˆæ—¶é—´è½´åˆ»åº¦æ•°æ®
 */
export function generateScrubberMarks(
  groups: { date: string }[]
): { date: string; label: string; position: number }[] {
  if (groups.length === 0) return [];
  
  const marks: { date: string; label: string; position: number }[] = [];
  let lastYear = '';
  let lastMonth = '';
  
  groups.forEach((group, index) => {
    const date = new Date(group.date);
    const year = date.getFullYear().toString();
    const month = `${year}-${date.getMonth() + 1}`;
    const position = (index / (groups.length - 1)) * 100;
    
    // æ¯å¹´æ·»åŠ å¹´ä»½æ ‡è®°
    if (year !== lastYear) {
      marks.push({
        date: group.date,
        label: year,
        position,
      });
      lastYear = year;
      lastMonth = month;
    }
    // æ¯æœˆæ·»åŠ æœˆä»½æ ‡è®°ï¼ˆå¯é€‰ï¼Œé¿å…å¤ªå¯†é›†ï¼‰
    else if (month !== lastMonth && groups.length < 100) {
      marks.push({
        date: group.date,
        label: `${date.getMonth() + 1}æœˆ`,
        position,
      });
      lastMonth = month;
    }
  });
  
  return marks;
}
```

### 7.3 ä¸»è§†å›¾ç»„ä»¶

```vue
<!-- src/components/timeline/TimelineView.vue -->
<template>
  <div class="timeline-view">
    <!-- ç²˜æ€§æ—¥æœŸæ ‡é¢˜ -->
    <TimelineStickyHeader 
      :date="currentDateLabel" 
      :visible="showStickyHeader"
    />

    <!-- å·¥å…·æ  -->
    <div class="timeline-toolbar">
      <div class="selection-info" v-if="selectedCount > 0">
        å·²é€‰æ‹© {{ selectedCount }} å¼ å›¾ç‰‡
        <button @click="clearSelection">å–æ¶ˆé€‰æ‹©</button>
        <button @click="copySelectedLinks">å¤åˆ¶é“¾æ¥</button>
      </div>
      <div class="view-options">
        <button @click="toggleGridSize">
          {{ gridSize === 'small' ? 'å¤§å›¾' : 'å°å›¾' }}
        </button>
      </div>
    </div>

    <!-- ä¸»å†…å®¹åŒº -->
    <div 
      ref="scrollContainer"
      class="timeline-scroll-container"
      @scroll="handleScroll"
    >
      <div class="timeline-content" :style="{ height: totalHeight + 'px' }">
        <template v-for="(group, index) in visibleGroups" :key="group.date">
          <TimelineDateGroup
            :group="group"
            :style="{ transform: `translateY(${group.offsetTop}px)` }"
            :grid-size="gridSize"
            :selected-ids="selectedIds"
            @select="handleImageSelect"
            @preview="handleImagePreview"
          />
        </template>
      </div>
    </div>

    <!-- æ—¶é—´è½´æ»‘å— -->
    <TimelineScrubber
      :marks="scrubberMarks"
      :current-position="scrubberPosition"
      @seek="handleScrubberSeek"
    />

    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-if="isLoading" class="timeline-loading">
      <span class="spinner"></span>
      åŠ è½½ä¸­...
    </div>

    <!-- ç©ºçŠ¶æ€ -->
    <div v-if="!isLoading && groups.length === 0" class="timeline-empty">
      <p>æš‚æ— ä¸Šä¼ è®°å½•</p>
      <p>ä¸Šä¼ å›¾ç‰‡åå°†åœ¨è¿™é‡Œæ˜¾ç¤º</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useTimelineStore } from '@/stores/timelineStore';
import { useVirtualScroll } from '@/composables/useVirtualScroll';
import { generateScrubberMarks } from '@/utils/dateUtils';
import TimelineStickyHeader from './TimelineStickyHeader.vue';
import TimelineDateGroup from './TimelineDateGroup.vue';
import TimelineScrubber from './TimelineScrubber.vue';

const store = useTimelineStore();
const { groups, selectedIds, selectedCount, currentDate, isLoading } = storeToRefs(store);

// æ»šåŠ¨å®¹å™¨
const scrollContainer = ref<HTMLElement | null>(null);

// ç½‘æ ¼å¤§å°
const gridSize = ref<'small' | 'large'>('small');

// è™šæ‹Ÿæ»šåŠ¨
const {
  visibleGroups,
  totalHeight,
  scrubberPosition,
  updateScroll,
  scrollToGroup,
} = useVirtualScroll(groups, scrollContainer, { gridSize });

// ç²˜æ€§æ ‡é¢˜
const showStickyHeader = ref(false);
const currentDateLabel = computed(() => {
  const group = groups.value.find(g => g.date === currentDate.value);
  return group?.displayLabel || '';
});

// æ—¶é—´è½´åˆ»åº¦
const scrubberMarks = computed(() => generateScrubberMarks(groups.value));

// æ»šåŠ¨å¤„ç†
function handleScroll(e: Event) {
  const target = e.target as HTMLElement;
  updateScroll(target.scrollTop);
  showStickyHeader.value = target.scrollTop > 50;
}

// å›¾ç‰‡é€‰æ‹©
function handleImageSelect(id: string, event: MouseEvent) {
  if (event.shiftKey && store.selectedIds.size > 0) {
    const lastSelected = Array.from(store.selectedIds).pop()!;
    store.selectRange(lastSelected, id);
  } else {
    store.selectImage(id, event.ctrlKey || event.metaKey);
  }
}

// å›¾ç‰‡é¢„è§ˆ
function handleImagePreview(image: UploadRecord) {
  // æ‰“å¼€å›¾ç‰‡é¢„è§ˆå¼¹çª—
  console.log('Preview:', image);
}

// æ—¶é—´è½´æ»‘å—è·³è½¬
function handleScrubberSeek(date: string) {
  const index = groups.value.findIndex(g => g.date === date);
  if (index !== -1) {
    scrollToGroup(index);
  }
}

// å¤åˆ¶é€‰ä¸­å›¾ç‰‡é“¾æ¥
function copySelectedLinks() {
  const links = store.selectedImages
    .flatMap(img => img.uploadResults.filter(r => r.success).map(r => r.url))
    .join('\n');
  navigator.clipboard.writeText(links);
}

// æ¸…é™¤é€‰æ‹©
function clearSelection() {
  store.clearSelection();
}

// åˆ‡æ¢ç½‘æ ¼å¤§å°
function toggleGridSize() {
  gridSize.value = gridSize.value === 'small' ? 'large' : 'small';
}

// åˆå§‹åŒ–
onMounted(() => {
  store.loadRecords();
});
</script>

<style scoped lang="scss">
.timeline-view {
  position: relative;
  display: flex;
  flex-direction: column;
  height: 100%;
  background: var(--bg-primary);
}

.timeline-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  
  .selection-info {
    display: flex;
    align-items: center;
    gap: 12px;
  }
}

.timeline-scroll-container {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  position: relative;
}

.timeline-content {
  position: relative;
  width: 100%;
}

.timeline-loading,
.timeline-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 48px;
  color: var(--text-secondary);
}

.spinner {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border-color);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
</style>
```

### 7.4 æ—¥æœŸåˆ†ç»„ç»„ä»¶

```vue
<!-- src/components/timeline/TimelineDateGroup.vue -->
<template>
  <div class="timeline-date-group" :data-date="group.date">
    <!-- æ—¥æœŸæ ‡é¢˜ -->
    <div class="date-header">
      <h3>{{ group.displayLabel }}</h3>
      <span class="image-count">{{ group.images.length }} å¼ å›¾ç‰‡</span>
    </div>

    <!-- å›¾ç‰‡ç½‘æ ¼ -->
    <div 
      class="image-grid" 
      :class="[`grid-${gridSize}`]"
    >
      <TimelineImage
        v-for="image in group.images"
        :key="image.id"
        :image="image"
        :selected="selectedIds.has(image.id)"
        @select="(e) => $emit('select', image.id, e)"
        @preview="$emit('preview', image)"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import type { TimelineDateGroup } from '@/types/timeline';
import TimelineImage from './TimelineImage.vue';

defineProps<{
  group: TimelineDateGroup;
  gridSize: 'small' | 'large';
  selectedIds: Set<string>;
}>();

defineEmits<{
  select: [id: string, event: MouseEvent];
  preview: [image: UploadRecord];
}>();
</script>

<style scoped lang="scss">
.timeline-date-group {
  padding: 0 16px 24px;
}

.date-header {
  display: flex;
  align-items: baseline;
  gap: 12px;
  padding: 16px 0 12px;
  position: sticky;
  top: 0;
  background: var(--bg-primary);
  z-index: 10;

  h3 {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
  }

  .image-count {
    font-size: 12px;
    color: var(--text-secondary);
  }
}

.image-grid {
  display: grid;
  gap: 4px;

  &.grid-small {
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  }

  &.grid-large {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }
}
</style>
```

### 7.5 å›¾ç‰‡ç»„ä»¶

```vue
<!-- src/components/timeline/TimelineImage.vue -->
<template>
  <div 
    class="timeline-image"
    :class="{ selected }"
    @click="handleClick"
    @dblclick="$emit('preview', image)"
  >
    <!-- ç¼©ç•¥å›¾ -->
    <div class="thumbnail-wrapper">
      <img
        v-if="isVisible"
        :src="thumbnailSrc"
        :alt="image.originalName"
        loading="lazy"
        @load="onImageLoad"
        @error="onImageError"
      />
      <div v-else class="placeholder"></div>
      
      <!-- åŠ è½½çŠ¶æ€ -->
      <div v-if="isLoading" class="loading-overlay">
        <span class="spinner-small"></span>
      </div>
    </div>

    <!-- é€‰æ‹©æ¡† -->
    <div 
      class="select-checkbox"
      :class="{ visible: selected || isHovered }"
      @click.stop="handleSelect"
    >
      <svg v-if="selected" viewBox="0 0 24 24" fill="currentColor">
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
      </svg>
    </div>

    <!-- æ‚¬åœä¿¡æ¯ -->
    <div class="hover-info" v-if="isHovered">
      <span class="filename">{{ image.originalName }}</span>
      <span class="platforms">
        <span 
          v-for="result in successfulUploads" 
          :key="result.platform"
          class="platform-badge"
        >
          {{ result.platform }}
        </span>
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useIntersectionObserver } from '@vueuse/core';
import type { UploadRecord } from '@/types/timeline';

const props = defineProps<{
  image: UploadRecord;
  selected: boolean;
}>();

const emit = defineEmits<{
  select: [event: MouseEvent];
  preview: [image: UploadRecord];
}>();

const imageRef = ref<HTMLElement | null>(null);
const isVisible = ref(false);
const isLoading = ref(true);
const isHovered = ref(false);
const hasError = ref(false);

// æ‡’åŠ è½½
useIntersectionObserver(
  imageRef,
  ([{ isIntersecting }]) => {
    if (isIntersecting) {
      isVisible.value = true;
    }
  },
  { rootMargin: '100px' }
);

// ç¼©ç•¥å›¾åœ°å€
const thumbnailSrc = computed(() => {
  if (props.image.thumbnailPath) {
    return `asset://localhost/${props.image.thumbnailPath}`;
  }
  // å›é€€åˆ°ç¬¬ä¸€ä¸ªæˆåŠŸçš„å›¾åºŠé“¾æ¥
  const firstSuccess = props.image.uploadResults.find(r => r.success);
  return firstSuccess?.url || '';
});

// æˆåŠŸä¸Šä¼ çš„å¹³å°
const successfulUploads = computed(() => 
  props.image.uploadResults.filter(r => r.success)
);

function handleClick(e: MouseEvent) {
  if (e.ctrlKey || e.metaKey || e.shiftKey) {
    handleSelect(e);
  }
}

function handleSelect(e: MouseEvent) {
  emit('select', e);
}

function onImageLoad() {
  isLoading.value = false;
}

function onImageError() {
  isLoading.value = false;
  hasError.value = true;
}
</script>

<style scoped lang="scss">
.timeline-image {
  position: relative;
  aspect-ratio: 1;
  border-radius: 4px;
  overflow: hidden;
  cursor: pointer;
  background: var(--bg-secondary);

  &:hover {
    .select-checkbox {
      opacity: 1;
    }
    .hover-info {
      opacity: 1;
    }
  }

  &.selected {
    outline: 3px solid var(--primary-color);
    outline-offset: -3px;

    .thumbnail-wrapper::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(var(--primary-rgb), 0.2);
    }
  }
}

.thumbnail-wrapper {
  width: 100%;
  height: 100%;
  position: relative;

  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .placeholder {
    width: 100%;
    height: 100%;
    background: var(--bg-tertiary);
  }
}

.select-checkbox {
  position: absolute;
  top: 8px;
  left: 8px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  border: 2px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s ease;

  &.visible {
    opacity: 1;
  }

  svg {
    width: 16px;
    height: 16px;
    color: var(--primary-color);
  }
}

.hover-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 8px;
  background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
  color: white;
  font-size: 12px;
  opacity: 0;
  transition: opacity 0.15s ease;

  .filename {
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .platforms {
    display: flex;
    gap: 4px;
    margin-top: 4px;
  }

  .platform-badge {
    padding: 2px 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    font-size: 10px;
    text-transform: uppercase;
  }
}

.loading-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-secondary);
}

.spinner-small {
  width: 20px;
  height: 20px;
  border: 2px solid var(--border-color);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
</style>
```

### 7.6 æ—¶é—´è½´æ»‘å—ç»„ä»¶

```vue
<!-- src/components/timeline/TimelineScrubber.vue -->
<template>
  <div 
    class="timeline-scrubber"
    @mousedown="startDrag"
    @touchstart="startDrag"
  >
    <!-- è½¨é“ -->
    <div class="scrubber-track" ref="trackRef">
      <!-- åˆ»åº¦ -->
      <div 
        v-for="mark in marks" 
        :key="mark.date"
        class="scrubber-mark"
        :style="{ top: mark.position + '%' }"
      >
        <span class="mark-label">{{ mark.label }}</span>
      </div>

      <!-- æ»‘å— -->
      <div 
        class="scrubber-thumb"
        :style="{ top: currentPosition + '%' }"
      >
        <div class="thumb-indicator"></div>
      </div>
    </div>

    <!-- æ‹–åŠ¨é¢„è§ˆ -->
    <Transition name="fade">
      <div 
        v-if="isDragging && previewDate"
        class="drag-preview"
        :style="{ top: dragPosition + '%' }"
      >
        {{ previewDateLabel }}
      </div>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { formatDateLabel } from '@/utils/dateUtils';

const props = defineProps<{
  marks: { date: string; label: string; position: number }[];
  currentPosition: number;
}>();

const emit = defineEmits<{
  seek: [date: string];
}>();

const trackRef = ref<HTMLElement | null>(null);
const isDragging = ref(false);
const dragPosition = ref(0);
const previewDate = ref<string | null>(null);

const previewDateLabel = computed(() => 
  previewDate.value ? formatDateLabel(previewDate.value) : ''
);

function startDrag(e: MouseEvent | TouchEvent) {
  isDragging.value = true;
  updateDragPosition(e);
  
  window.addEventListener('mousemove', onDrag);
  window.addEventListener('mouseup', endDrag);
  window.addEventListener('touchmove', onDrag);
  window.addEventListener('touchend', endDrag);
}

function onDrag(e: MouseEvent | TouchEvent) {
  if (!isDragging.value) return;
  updateDragPosition(e);
}

function updateDragPosition(e: MouseEvent | TouchEvent) {
  if (!trackRef.value) return;
  
  const rect = trackRef.value.getBoundingClientRect();
  const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
  const position = Math.max(0, Math.min(100, 
    ((clientY - rect.top) / rect.height) * 100
  ));
  
  dragPosition.value = position;
  
  // æ‰¾åˆ°æœ€è¿‘çš„åˆ»åº¦
  const nearestMark = props.marks.reduce((nearest, mark) => {
    const diff = Math.abs(mark.position - position);
    return diff < Math.abs(nearest.position - position) ? mark : nearest;
  }, props.marks[0]);
  
  if (nearestMark) {
    previewDate.value = nearestMark.date;
  }
}

function endDrag() {
  isDragging.value = false;
  
  if (previewDate.value) {
    emit('seek', previewDate.value);
  }
  
  previewDate.value = null;
  
  window.removeEventListener('mousemove', onDrag);
  window.removeEventListener('mouseup', endDrag);
  window.removeEventListener('touchmove', onDrag);
  window.removeEventListener('touchend', endDrag);
}
</script>

<style scoped lang="scss">
.timeline-scrubber {
  position: absolute;
  right: 0;
  top: 60px;
  bottom: 0;
  width: 48px;
  display: flex;
  justify-content: center;
  z-index: 100;
}

.scrubber-track {
  position: relative;
  width: 4px;
  height: 100%;
  background: var(--border-color);
  border-radius: 2px;
}

.scrubber-mark {
  position: absolute;
  right: 12px;
  transform: translateY(-50%);

  .mark-label {
    font-size: 10px;
    color: var(--text-secondary);
    white-space: nowrap;
  }
}

.scrubber-thumb {
  position: absolute;
  left: 50%;
  transform: translate(-50%, -50%);
  cursor: grab;

  &:active {
    cursor: grabbing;
  }

  .thumb-indicator {
    width: 12px;
    height: 12px;
    background: var(--primary-color);
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
}

.drag-preview {
  position: absolute;
  right: 24px;
  transform: translateY(-50%);
  padding: 6px 12px;
  background: var(--bg-elevated);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  font-size: 12px;
  font-weight: 500;
  white-space: nowrap;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.15s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

### 7.7 è™šæ‹Ÿæ»šåŠ¨ Composable

```typescript
// src/composables/useVirtualScroll.ts

import { ref, computed, watch, type Ref } from 'vue';
import type { TimelineDateGroup } from '@/types/timeline';

interface VirtualScrollOptions {
  gridSize: Ref<'small' | 'large'>;
  overscan?: number;
}

export function useVirtualScroll(
  groups: Ref<TimelineDateGroup[]>,
  containerRef: Ref<HTMLElement | null>,
  options: VirtualScrollOptions
) {
  const { gridSize, overscan = 3 } = options;

  const scrollTop = ref(0);
  const containerHeight = ref(0);

  // ä¼°ç®—æ¯ä¸ªåˆ†ç»„çš„é«˜åº¦
  const estimateGroupHeight = (group: TimelineDateGroup): number => {
    const headerHeight = 52; // æ—¥æœŸæ ‡é¢˜é«˜åº¦
    const gap = 4;
    const itemSize = gridSize.value === 'small' ? 124 : 204;
    const containerWidth = containerRef.value?.clientWidth || 800;
    const itemsPerRow = Math.floor((containerWidth - 32) / itemSize);
    const rows = Math.ceil(group.images.length / itemsPerRow);
    return headerHeight + rows * itemSize + (rows - 1) * gap + 24; // 24 åº•éƒ¨é—´è·
  };

  // è®¡ç®—æ‰€æœ‰åˆ†ç»„çš„ä½ç½®
  const groupPositions = computed(() => {
    let offset = 0;
    return groups.value.map((group, index) => {
      const height = estimateGroupHeight(group);
      const position = {
        index,
        offsetTop: offset,
        height,
        group,
      };
      offset += height;
      return position;
    });
  });

  // æ€»é«˜åº¦
  const totalHeight = computed(() => {
    const positions = groupPositions.value;
    if (positions.length === 0) return 0;
    const last = positions[positions.length - 1];
    return last.offsetTop + last.height;
  });

  // å¯è§çš„åˆ†ç»„
  const visibleGroups = computed(() => {
    const positions = groupPositions.value;
    const viewTop = scrollTop.value;
    const viewBottom = viewTop + containerHeight.value;

    const visible: (TimelineDateGroup & { offsetTop: number })[] = [];

    for (const pos of positions) {
      const groupTop = pos.offsetTop;
      const groupBottom = groupTop + pos.height;

      // åŒ…å« overscan
      if (groupBottom >= viewTop - pos.height * overscan && 
          groupTop <= viewBottom + pos.height * overscan) {
        visible.push({
          ...pos.group,
          offsetTop: pos.offsetTop,
        });
      }
    }

    return visible;
  });

  // å½“å‰ä½ç½®ç™¾åˆ†æ¯”ï¼ˆç”¨äºæ—¶é—´è½´æ»‘å—ï¼‰
  const scrubberPosition = computed(() => {
    if (totalHeight.value === 0) return 0;
    return (scrollTop.value / totalHeight.value) * 100;
  });

  // å½“å‰å¯è§çš„æ—¥æœŸ
  const currentVisibleDate = computed(() => {
    const positions = groupPositions.value;
    const viewTop = scrollTop.value + 60; // è€ƒè™‘é¡¶éƒ¨åç§»

    for (const pos of positions) {
      if (pos.offsetTop + pos.height > viewTop) {
        return pos.group.date;
      }
    }

    return positions[0]?.group.date || null;
  });

  // æ›´æ–°æ»šåŠ¨ä½ç½®
  function updateScroll(top: number) {
    scrollTop.value = top;
  }

  // æ»šåŠ¨åˆ°æŒ‡å®šåˆ†ç»„
  function scrollToGroup(index: number) {
    const positions = groupPositions.value;
    if (index < 0 || index >= positions.length) return;

    const targetPosition = positions[index].offsetTop;
    containerRef.value?.scrollTo({
      top: targetPosition,
      behavior: 'smooth',
    });
  }

  // ç›‘å¬å®¹å™¨å¤§å°å˜åŒ–
  watch(containerRef, (container) => {
    if (container) {
      containerHeight.value = container.clientHeight;
      
      const observer = new ResizeObserver((entries) => {
        containerHeight.value = entries[0].contentRect.height;
      });
      observer.observe(container);
    }
  }, { immediate: true });

  return {
    visibleGroups,
    totalHeight,
    scrubberPosition,
    currentVisibleDate,
    updateScroll,
    scrollToGroup,
  };
}
```

### 7.8 Rust åç«¯å‘½ä»¤

```rust
// src-tauri/src/commands/timeline.rs

use tauri::command;
use crate::db::Database;
use crate::models::timeline::{UploadRecord, TimelineQuery};

#[command]
pub async fn get_upload_history(
    query: Option<TimelineQuery>,
    db: tauri::State<'_, Database>,
) -> Result<Vec<UploadRecord>, String> {
    let query = query.unwrap_or_default();
    
    let mut sql = String::from(
        "SELECT id, original_name, thumbnail_path, upload_time, 
                file_size, width, height, upload_results
         FROM upload_history"
    );
    
    let mut conditions = Vec::new();
    
    if let Some(start) = query.start_date {
        conditions.push(format!("upload_time >= {}", start));
    }
    
    if let Some(end) = query.end_date {
        conditions.push(format!("upload_time <= {}", end));
    }
    
    if !conditions.is_empty() {
        sql.push_str(" WHERE ");
        sql.push_str(&conditions.join(" AND "));
    }
    
    sql.push_str(" ORDER BY upload_time DESC");
    
    if let Some(limit) = query.limit {
        sql.push_str(&format!(" LIMIT {}", limit));
    }
    
    if let Some(offset) = query.offset {
        sql.push_str(&format!(" OFFSET {}", offset));
    }
    
    db.query_records(&sql)
        .map_err(|e| e.to_string())
}

#[command]
pub async fn get_timeline_stats(
    db: tauri::State<'_, Database>,
) -> Result<TimelineStats, String> {
    let sql = "
        SELECT 
            COUNT(*) as total_count,
            MIN(upload_time) as earliest,
            MAX(upload_time) as latest
        FROM upload_history
    ";
    
    db.query_stats(sql)
        .map_err(|e| e.to_string())
}

#[derive(serde::Serialize)]
pub struct TimelineStats {
    pub total_count: i64,
    pub earliest: Option<i64>,
    pub latest: Option<i64>,
}
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 å›¾ç‰‡åŠ è½½ä¼˜åŒ–

```typescript
// ç¼©ç•¥å›¾ç”Ÿæˆç­–ç•¥
interface ThumbnailConfig {
  maxWidth: 300,
  maxHeight: 300,
  quality: 0.8,
  format: 'webp' | 'jpeg',
}

// åœ¨ä¸Šä¼ æ—¶ç”Ÿæˆç¼©ç•¥å›¾ï¼ˆRust ç«¯ï¼‰
// ä½¿ç”¨ image crate è¿›è¡Œå‹ç¼©
```

### 8.2 æ»šåŠ¨æ€§èƒ½ä¼˜åŒ–

| ä¼˜åŒ–é¡¹ | æ–¹æ³• |
|--------|------|
| **é˜²æŠ–æ»šåŠ¨äº‹ä»¶** | ä½¿ç”¨ `requestAnimationFrame` æˆ– `lodash.throttle` |
| **CSS ç¡¬ä»¶åŠ é€Ÿ** | ä½¿ç”¨ `transform` è€Œé `top/left` |
| **é¿å…é‡æ’** | å›ºå®šå›¾ç‰‡å®¹å™¨å°ºå¯¸ï¼Œä½¿ç”¨ `aspect-ratio` |
| **å›¾ç‰‡æ‡’åŠ è½½** | ä½¿ç”¨ `IntersectionObserver` |
| **è™šæ‹Ÿæ»šåŠ¨** | ä»…æ¸²æŸ“å¯è§åŒºåŸŸ + overscan |

### 8.3 å†…å­˜ä¼˜åŒ–

```typescript
// å›¾ç‰‡ URL é‡Šæ”¾
function cleanupImageUrls(urls: string[]) {
  urls.forEach(url => {
    if (url.startsWith('blob:')) {
      URL.revokeObjectURL(url);
    }
  });
}

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†
onUnmounted(() => {
  cleanupImageUrls(loadedThumbnails.value);
});
```

### 8.4 æ•°æ®åŠ è½½ç­–ç•¥

```typescript
// åˆ†é¡µåŠ è½½
const PAGE_SIZE = 100;

async function loadMore() {
  if (isLoading.value || !hasMore.value) return;
  
  const newRecords = await invoke<UploadRecord[]>('get_upload_history', {
    query: {
      limit: PAGE_SIZE,
      offset: records.value.length,
    }
  });
  
  if (newRecords.length < PAGE_SIZE) {
    hasMore.value = false;
  }
  
  records.value.push(...newRecords);
}
```

---

## 9. æµ‹è¯•è¦ç‚¹

### 9.1 å•å…ƒæµ‹è¯•

```typescript
// tests/utils/dateUtils.test.ts
import { describe, it, expect } from 'vitest';
import { formatDateLabel, groupByDate } from '@/utils/dateUtils';

describe('formatDateLabel', () => {
  it('should return "ä»Šå¤©" for today', () => {
    const today = new Date().toISOString().split('T')[0];
    expect(formatDateLabel(today)).toBe('ä»Šå¤©');
  });

  it('should return "æ˜¨å¤©" for yesterday', () => {
    const yesterday = new Date(Date.now() - 86400000)
      .toISOString().split('T')[0];
    expect(formatDateLabel(yesterday)).toBe('æ˜¨å¤©');
  });

  it('should include year for different year', () => {
    expect(formatDateLabel('2020-05-15')).toContain('2020');
  });
});
```

### 9.2 E2E æµ‹è¯•

```typescript
// tests/e2e/timeline.spec.ts
import { test, expect } from '@playwright/test';

test('timeline scrolling', async ({ page }) => {
  await page.goto('/timeline');
  
  // ç­‰å¾…åŠ è½½å®Œæˆ
  await page.waitForSelector('.timeline-date-group');
  
  // æ»šåŠ¨æµ‹è¯•
  await page.evaluate(() => {
    document.querySelector('.timeline-scroll-container')
      ?.scrollTo({ top: 1000 });
  });
  
  // éªŒè¯ç²˜æ€§æ ‡é¢˜æ›´æ–°
  await expect(page.locator('.sticky-header')).toBeVisible();
});

test('image selection', async ({ page }) => {
  await page.goto('/timeline');
  
  // ç‚¹å‡»é€‰æ‹©å›¾ç‰‡
  await page.click('.timeline-image:first-child');
  await expect(page.locator('.timeline-image.selected')).toHaveCount(1);
  
  // Ctrl + ç‚¹å‡»å¤šé€‰
  await page.click('.timeline-image:nth-child(2)', { modifiers: ['Control'] });
  await expect(page.locator('.timeline-image.selected')).toHaveCount(2);
});
```

### 9.3 æ€§èƒ½æµ‹è¯•

```typescript
// æµ‹è¯•å¤§é‡å›¾ç‰‡çš„æ¸²æŸ“æ€§èƒ½
test('renders 10000 images smoothly', async ({ page }) => {
  // Mock 10000 æ¡æ•°æ®
  await page.route('**/get_upload_history', (route) => {
    route.fulfill({
      body: JSON.stringify(generateMockRecords(10000)),
    });
  });
  
  await page.goto('/timeline');
  
  // æµ‹è¯•æ»šåŠ¨å¸§ç‡
  const fps = await page.evaluate(async () => {
    return new Promise((resolve) => {
      let frames = 0;
      const start = performance.now();
      
      const container = document.querySelector('.timeline-scroll-container');
      container?.scrollTo({ top: 50000, behavior: 'smooth' });
      
      function count() {
        frames++;
        if (performance.now() - start < 2000) {
          requestAnimationFrame(count);
        } else {
          resolve(frames / 2); // FPS
        }
      }
      requestAnimationFrame(count);
    });
  });
  
  expect(fps).toBeGreaterThan(30);
});
```

---

## é™„å½•ï¼šCSS å˜é‡å‚è€ƒ

```css
:root {
  /* é¢œè‰² */
  --primary-color: #1a73e8;
  --primary-rgb: 26, 115, 232;
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e0e0e0;
  --bg-elevated: #ffffff;
  --text-primary: #202124;
  --text-secondary: #5f6368;
  --border-color: #dadce0;
  
  /* æš—è‰²ä¸»é¢˜ */
  @media (prefers-color-scheme: dark) {
    --bg-primary: #202124;
    --bg-secondary: #303134;
    --bg-tertiary: #3c4043;
    --bg-elevated: #3c4043;
    --text-primary: #e8eaed;
    --text-secondary: #9aa0a6;
    --border-color: #5f6368;
  }
}
```

---

## è”ç³»ä¸åé¦ˆ

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿æäº¤ Issue æˆ– PRã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬: 1.0.0*  
*æœ€åæ›´æ–°: 2026-01-11*
