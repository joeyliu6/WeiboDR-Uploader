# PicNexus æ—¶é—´è½´æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

## æ¦‚è¿°

æœ¬æ–‡æ¡£è§£å†³ä¸‰ä¸ªæ ¸å¿ƒé—®é¢˜ï¼š

| é—®é¢˜ | ç°çŠ¶ | ç›®æ ‡ |
|------|------|------|
| æ•°æ®åŠ è½½ | ä¸€æ¬¡è·å– 500 æ¡ï¼Œé¦–å±æ…¢ | å…ƒæ•°æ® + æŒ‰éœ€åŠ è½½ï¼Œç§’å¼€ |
| è·³è½¬æ»šåŠ¨ | è·³è½¬åå‘ä¸Šæ»šåŠ¨å¤±æ•ˆ | ä»»æ„ä½ç½®è‡ªç”±æ»šåŠ¨ |
| æ—¶é—´è½´åŒæ­¥ | æ»‘å—ä¸é¡µé¢å†…å®¹ä¸ä¸€è‡´ | ç²¾ç¡®åŒæ­¥ |

---

## ä¸€ã€æ¶æ„è®¾è®¡

### 1.1 æ•°æ®åˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æ•°æ®åˆ†å±‚æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ç¬¬ä¸€å±‚ï¼šå…ƒæ•°æ®ï¼ˆå¯åŠ¨æ—¶å…¨é‡åŠ è½½ï¼‰                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ { id, uploadTime, width, height }                   â”‚    â”‚
â”‚  â”‚ 10000 å¼ å›¾ç‰‡ â‰ˆ 400KBï¼ŒåŠ è½½æ—¶é—´ < 100ms              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â†“                                 â”‚
â”‚  ç¬¬äºŒå±‚ï¼šå¸ƒå±€ä¿¡æ¯ï¼ˆæ ¹æ®å…ƒæ•°æ®è®¡ç®—ï¼‰                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ æ€»é«˜åº¦ã€æ¯ä¸ªæ—¥æœŸç»„çš„ä½ç½®ã€æ¯å¼ å›¾ç‰‡çš„ä½ç½®              â”‚    â”‚
â”‚  â”‚ è®¡ç®—ä¸€æ¬¡ï¼Œè·³è½¬/æ»šåŠ¨æ—¶ç›´æ¥æŸ¥è¡¨                        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â†“                                 â”‚
â”‚  ç¬¬ä¸‰å±‚ï¼šè¯¦ç»†æ•°æ®ï¼ˆæŒ‰éœ€åŠ è½½ï¼ŒLRU ç¼“å­˜ï¼‰                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ { thumbnailPath, uploadResults, originalName, ... } â”‚    â”‚
â”‚  â”‚ ä»…åŠ è½½å¯è§åŒºåŸŸ + ç¼“å†²åŒºï¼Œæœ€å¤šç¼“å­˜ 500 æ¡             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒåŸåˆ™

```
1. æ€»é«˜åº¦æ’å®š
   - å¯åŠ¨æ—¶æ ¹æ®å…ƒæ•°æ®è®¡ç®—å‡ºç²¾ç¡®çš„æ€»é«˜åº¦
   - æ— è®ºæ»šåŠ¨åˆ°å“ªé‡Œï¼Œå®¹å™¨é«˜åº¦ä¸å˜
   - è·³è½¬åªæ”¹å˜ scrollTopï¼Œä¸æ”¹å˜å¸ƒå±€

2. å•ä¸€æ•°æ®æº
   - scrollTop æ˜¯å”¯ä¸€çš„çœŸå®çŠ¶æ€
   - å½“å‰æ—¥æœŸã€æ»‘å—ä½ç½®ã€å¯è§èŒƒå›´éƒ½ä» scrollTop æ´¾ç”Ÿ
   - é¿å…å¤šçŠ¶æ€ä¸åŒæ­¥

3. ä½ç½®é¢„è®¡ç®—
   - æ¯ä¸ªæ—¥æœŸç»„çš„ offset åœ¨åˆå§‹åŒ–æ—¶è®¡ç®—å®Œæˆ
   - è·³è½¬æ—¶ç›´æ¥æŸ¥è¡¨ï¼ŒO(1) å¤æ‚åº¦
   - æ»šåŠ¨æ—¶äºŒåˆ†æŸ¥æ‰¾å½“å‰æ—¥æœŸï¼ŒO(log n) å¤æ‚åº¦
```

---

## äºŒã€æ•°æ®æ¨¡å‹

### 2.1 TypeScript ç±»å‹å®šä¹‰

```typescript
// types/timeline.ts

/** è½»é‡å…ƒæ•°æ®ï¼ˆå…¨é‡åŠ è½½ï¼‰ */
export interface ImageMeta {
  id: string;
  uploadTime: number;  // æ—¶é—´æˆ³ ms
  width: number;
  height: number;
}

/** å®Œæ•´è¯¦æƒ…ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰ */
export interface ImageDetail extends ImageMeta {
  originalName: string;
  thumbnailPath: string;
  fileSize: number;
  uploadResults: UploadResult[];
}

/** ä¸Šä¼ ç»“æœ */
export interface UploadResult {
  platform: string;
  url: string;
  success: boolean;
}

/** å¸ƒå±€ä¿¡æ¯ */
export interface LayoutInfo {
  totalHeight: number;
  groups: GroupLayout[];
  dateOffsetMap: Map<string, number>;  // date -> offset
}

/** æ—¥æœŸç»„å¸ƒå±€ */
export interface GroupLayout {
  date: string;
  label: string;           // "ä»Šå¤©" / "2024å¹´3æœˆ15æ—¥"
  offset: number;          // ç»„èµ·å§‹ä½ç½®
  height: number;          // ç»„æ€»é«˜åº¦
  itemStartIndex: number;  // è¯¥ç»„ç¬¬ä¸€å¼ å›¾ç‰‡åœ¨ allMeta ä¸­çš„ç´¢å¼•
  itemCount: number;       // è¯¥ç»„å›¾ç‰‡æ•°é‡
}

/** å¯è§èŒƒå›´ */
export interface VisibleRange {
  startIndex: number;
  endIndex: number;
  startOffset: number;
}
```

### 2.2 Rust æ•°æ®ç»“æ„

```rust
// src-tauri/src/models.rs

use serde::{Deserialize, Serialize};

/// è½»é‡å…ƒæ•°æ®
#[derive(Debug, Serialize, Deserialize)]
pub struct ImageMeta {
    pub id: String,
    pub upload_time: i64,
    pub width: u32,
    pub height: u32,
}

/// å®Œæ•´è¯¦æƒ…
#[derive(Debug, Serialize, Deserialize)]
pub struct ImageDetail {
    pub id: String,
    pub upload_time: i64,
    pub width: u32,
    pub height: u32,
    pub original_name: String,
    pub thumbnail_path: Option<String>,
    pub file_size: i64,
    pub upload_results: Vec<UploadResult>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UploadResult {
    pub platform: String,
    pub url: String,
    pub success: bool,
}
```

---

## ä¸‰ã€Rust åç«¯å®ç°

### 3.1 æ•°æ®åº“æŸ¥è¯¢

```rust
// src-tauri/src/commands/timeline.rs

use tauri::State;
use crate::db::Database;
use crate::models::{ImageMeta, ImageDetail};

/// è·å–æ‰€æœ‰å…ƒæ•°æ®ï¼ˆå¯åŠ¨æ—¶è°ƒç”¨ä¸€æ¬¡ï¼‰
#[tauri::command]
pub async fn get_all_metadata(
    db: State<'_, Database>
) -> Result<Vec<ImageMeta>, String> {
    // åªæŸ¥è¯¢å¿…è¦å­—æ®µï¼Œé€Ÿåº¦å¿«
    let sql = r#"
        SELECT id, upload_time, width, height 
        FROM upload_history 
        ORDER BY upload_time DESC
    "#;
    
    db.query_metadata(sql).map_err(|e| e.to_string())
}

/// æŒ‰ ID åˆ—è¡¨è·å–è¯¦æƒ…ï¼ˆæ»šåŠ¨æ—¶æŒ‰éœ€è°ƒç”¨ï¼‰
#[tauri::command]
pub async fn get_details_by_ids(
    ids: Vec<String>,
    db: State<'_, Database>
) -> Result<Vec<ImageDetail>, String> {
    if ids.is_empty() {
        return Ok(vec![]);
    }
    
    // æ„å»º IN æŸ¥è¯¢
    let placeholders: Vec<&str> = ids.iter().map(|_| "?").collect();
    let sql = format!(
        r#"
        SELECT id, upload_time, width, height, original_name, 
               thumbnail_path, file_size, upload_results
        FROM upload_history 
        WHERE id IN ({})
        "#,
        placeholders.join(",")
    );
    
    db.query_details(&sql, &ids).map_err(|e| e.to_string())
}

/// è·å–ç»Ÿè®¡ä¿¡æ¯
#[tauri::command]
pub async fn get_timeline_stats(
    db: State<'_, Database>
) -> Result<TimelineStats, String> {
    let sql = r#"
        SELECT 
            COUNT(*) as total,
            MIN(upload_time) as earliest,
            MAX(upload_time) as latest
        FROM upload_history
    "#;
    
    db.query_stats(sql).map_err(|e| e.to_string())
}

#[derive(serde::Serialize)]
pub struct TimelineStats {
    pub total: i64,
    pub earliest: Option<i64>,
    pub latest: Option<i64>,
}
```

### 3.2 æ³¨å†Œå‘½ä»¤

```rust
// src-tauri/src/main.rs

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            get_all_metadata,
            get_details_by_ids,
            get_timeline_stats,
            // ... å…¶ä»–å‘½ä»¤
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

---

## å››ã€å‰ç«¯æ ¸å¿ƒå®ç°

### 4.1 å¸ƒå±€è®¡ç®—å™¨

```typescript
// utils/layoutCalculator.ts

import type { ImageMeta, LayoutInfo, GroupLayout } from '@/types/timeline';

/** å¸ƒå±€é…ç½® */
interface LayoutConfig {
  containerWidth: number;    // å®¹å™¨å®½åº¦
  itemGap: number;           // å›¾ç‰‡é—´è·
  itemMinWidth: number;      // å›¾ç‰‡æœ€å°å®½åº¦
  itemAspectRatio: number;   // å›¾ç‰‡å®½é«˜æ¯”ï¼ˆ1 = æ­£æ–¹å½¢ï¼‰
  headerHeight: number;      // æ—¥æœŸæ ‡é¢˜é«˜åº¦
  groupPaddingBottom: number; // æ—¥æœŸç»„åº•éƒ¨é—´è·
  sidePadding: number;       // å·¦å³å†…è¾¹è·
}

const DEFAULT_CONFIG: LayoutConfig = {
  containerWidth: 800,
  itemGap: 4,
  itemMinWidth: 120,
  itemAspectRatio: 1,
  headerHeight: 48,
  groupPaddingBottom: 16,
  sidePadding: 16,
};

/**
 * è®¡ç®—å®Œæ•´å¸ƒå±€ä¿¡æ¯
 * åªåœ¨å…ƒæ•°æ®å˜åŒ–æˆ–å®¹å™¨å®½åº¦å˜åŒ–æ—¶è°ƒç”¨
 */
export function calculateLayout(
  allMeta: ImageMeta[],
  config: Partial<LayoutConfig> = {}
): LayoutInfo {
  const cfg = { ...DEFAULT_CONFIG, ...config };
  
  if (allMeta.length === 0) {
    return { totalHeight: 0, groups: [], dateOffsetMap: new Map() };
  }
  
  // è®¡ç®—æ¯è¡Œå›¾ç‰‡æ•°é‡å’Œå®é™…å°ºå¯¸
  const contentWidth = cfg.containerWidth - cfg.sidePadding * 2;
  const itemsPerRow = Math.max(1, Math.floor(
    (contentWidth + cfg.itemGap) / (cfg.itemMinWidth + cfg.itemGap)
  ));
  const itemWidth = (contentWidth - (itemsPerRow - 1) * cfg.itemGap) / itemsPerRow;
  const itemHeight = itemWidth / cfg.itemAspectRatio;
  
  const groups: GroupLayout[] = [];
  const dateOffsetMap = new Map<string, number>();
  
  let currentOffset = 0;
  let currentDate = '';
  let currentGroup: GroupLayout | null = null;
  
  allMeta.forEach((meta, index) => {
    const date = timestampToDateKey(meta.uploadTime);
    
    // æ–°çš„æ—¥æœŸç»„
    if (date !== currentDate) {
      // ç»“æŸä¸Šä¸€ä¸ªç»„
      if (currentGroup) {
        const rows = Math.ceil(currentGroup.itemCount / itemsPerRow);
        currentGroup.height = cfg.headerHeight + rows * itemHeight + 
                              (rows - 1) * cfg.itemGap + cfg.groupPaddingBottom;
        currentOffset += currentGroup.height;
      }
      
      // å¼€å§‹æ–°ç»„
      currentGroup = {
        date,
        label: formatDateLabel(date),
        offset: currentOffset,
        height: 0, // ç¨åè®¡ç®—
        itemStartIndex: index,
        itemCount: 0,
      };
      
      groups.push(currentGroup);
      dateOffsetMap.set(date, currentOffset);
      currentDate = date;
    }
    
    currentGroup!.itemCount++;
  });
  
  // å¤„ç†æœ€åä¸€ä¸ªç»„
  if (currentGroup) {
    const rows = Math.ceil(currentGroup.itemCount / itemsPerRow);
    currentGroup.height = cfg.headerHeight + rows * itemHeight + 
                          (rows - 1) * cfg.itemGap + cfg.groupPaddingBottom;
    currentOffset += currentGroup.height;
  }
  
  return {
    totalHeight: currentOffset,
    groups,
    dateOffsetMap,
  };
}

/** æ—¶é—´æˆ³è½¬æ—¥æœŸ key */
function timestampToDateKey(ts: number): string {
  return new Date(ts).toISOString().split('T')[0];
}

/** æ ¼å¼åŒ–æ—¥æœŸæ ‡ç­¾ */
function formatDateLabel(dateKey: string): string {
  const date = new Date(dateKey);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const target = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  
  const diffDays = Math.floor((today.getTime() - target.getTime()) / 86400000);
  
  if (diffDays === 0) return 'ä»Šå¤©';
  if (diffDays === 1) return 'æ˜¨å¤©';
  if (diffDays < 7) return `${diffDays}å¤©å‰`;
  
  if (date.getFullYear() === now.getFullYear()) {
    return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
  }
  
  return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
}
```

### 4.2 LRU ç¼“å­˜

```typescript
// utils/LRUCache.ts

export class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private readonly maxSize: number;

  constructor(maxSize: number = 500) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    if (!this.cache.has(key)) return undefined;
    
    // è®¿é—®æ—¶ç§»åˆ°æœ«å°¾ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
    const value = this.cache.get(key)!;
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  set(key: K, value: V): void {
    // å·²å­˜åœ¨åˆ™å…ˆåˆ é™¤
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    // è¶…å‡ºå®¹é‡åˆ™åˆ é™¤æœ€æ—§çš„
    else if (this.cache.size >= this.maxSize) {
      const oldest = this.cache.keys().next().value;
      this.cache.delete(oldest);
    }
    
    this.cache.set(key, value);
  }

  has(key: K): boolean {
    return this.cache.has(key);
  }

  setMany(entries: [K, V][]): void {
    entries.forEach(([k, v]) => this.set(k, v));
  }

  clear(): void {
    this.cache.clear();
  }

  get size(): number {
    return this.cache.size;
  }
}
```

### 4.3 æ ¸å¿ƒ Composable

```typescript
// composables/useVirtualTimeline.ts

import { ref, computed, watch, readonly, type Ref } from 'vue';
import { invoke } from '@tauri-apps/api/tauri';
import { calculateLayout } from '@/utils/layoutCalculator';
import { LRUCache } from '@/utils/LRUCache';
import type { 
  ImageMeta, 
  ImageDetail, 
  LayoutInfo, 
  VisibleRange,
  GroupLayout 
} from '@/types/timeline';

interface UseVirtualTimelineOptions {
  bufferSize?: number;      // ä¸Šä¸‹ç¼“å†²åŒºå¤§å°ï¼ˆåƒç´ ï¼‰
  cacheSize?: number;       // è¯¦æƒ…ç¼“å­˜æ•°é‡
  batchSize?: number;       // æ¯æ¬¡åŠ è½½çš„æ•°é‡
}

export function useVirtualTimeline(
  containerRef: Ref<HTMLElement | null>,
  options: UseVirtualTimelineOptions = {}
) {
  const {
    bufferSize = 500,
    cacheSize = 500,
    batchSize = 50,
  } = options;

  // ==================== çŠ¶æ€ ====================
  
  /** æ‰€æœ‰å…ƒæ•°æ® */
  const allMeta = ref<ImageMeta[]>([]);
  
  /** å¸ƒå±€ä¿¡æ¯ */
  const layoutInfo = ref<LayoutInfo>({
    totalHeight: 0,
    groups: [],
    dateOffsetMap: new Map(),
  });
  
  /** è¯¦æƒ…ç¼“å­˜ */
  const detailCache = new LRUCache<string, ImageDetail>(cacheSize);
  
  /** å·²åŠ è½½è¯¦æƒ…çš„å›¾ç‰‡ï¼ˆç”¨äºæ¸²æŸ“ï¼‰ */
  const loadedDetails = ref<Map<string, ImageDetail>>(new Map());
  
  /** æ»šåŠ¨ä½ç½®ï¼ˆå•ä¸€æ•°æ®æºï¼‰ */
  const scrollTop = ref(0);
  
  /** å®¹å™¨é«˜åº¦ */
  const viewportHeight = ref(0);
  
  /** åŠ è½½çŠ¶æ€ */
  const isInitializing = ref(true);
  const isLoadingDetails = ref(false);
  
  /** é”™è¯¯ä¿¡æ¯ */
  const error = ref<string | null>(null);

  // ==================== æ´¾ç”ŸçŠ¶æ€ ====================
  
  /** æ€»é«˜åº¦ */
  const totalHeight = computed(() => layoutInfo.value.totalHeight);
  
  /** å½“å‰å¯è§çš„æ—¥æœŸï¼ˆä» scrollTop æ´¾ç”Ÿï¼‰ */
  const currentDate = computed(() => {
    const offset = scrollTop.value + 60; // åç§»é‡ï¼Œè®©æ ‡é¢˜åˆšç¦»å¼€è§†å£æ—¶åˆ‡æ¢
    const groups = layoutInfo.value.groups;
    
    // äºŒåˆ†æŸ¥æ‰¾
    let left = 0;
    let right = groups.length - 1;
    
    while (left < right) {
      const mid = Math.floor((left + right + 1) / 2);
      if (groups[mid].offset <= offset) {
        left = mid;
      } else {
        right = mid - 1;
      }
    }
    
    return groups[left]?.date ?? null;
  });
  
  /** å½“å‰æ—¥æœŸçš„æ˜¾ç¤ºæ–‡æœ¬ */
  const currentDateLabel = computed(() => {
    const date = currentDate.value;
    if (!date) return '';
    const group = layoutInfo.value.groups.find(g => g.date === date);
    return group?.label ?? '';
  });
  
  /** æ—¶é—´è½´æ»‘å—ä½ç½®ï¼ˆä» scrollTop æ´¾ç”Ÿï¼‰ */
  const scrubberPosition = computed(() => {
    const total = totalHeight.value;
    if (total === 0) return 0;
    return Math.min(100, Math.max(0, (scrollTop.value / total) * 100));
  });
  
  /** å¯è§èŒƒå›´ */
  const visibleRange = computed<VisibleRange>(() => {
    const groups = layoutInfo.value.groups;
    if (groups.length === 0) {
      return { startIndex: 0, endIndex: 0, startOffset: 0 };
    }
    
    const viewStart = Math.max(0, scrollTop.value - bufferSize);
    const viewEnd = scrollTop.value + viewportHeight.value + bufferSize;
    
    // æ‰¾åˆ°å¯è§çš„ç»„èŒƒå›´
    let startGroupIdx = 0;
    let endGroupIdx = groups.length - 1;
    
    // äºŒåˆ†æŸ¥æ‰¾èµ·å§‹ç»„
    let left = 0;
    let right = groups.length - 1;
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (groups[mid].offset + groups[mid].height < viewStart) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }
    startGroupIdx = left;
    
    // äºŒåˆ†æŸ¥æ‰¾ç»“æŸç»„
    left = startGroupIdx;
    right = groups.length - 1;
    while (left < right) {
      const mid = Math.floor((left + right + 1) / 2);
      if (groups[mid].offset <= viewEnd) {
        left = mid;
      } else {
        right = mid - 1;
      }
    }
    endGroupIdx = left;
    
    // è½¬æ¢ä¸ºå›¾ç‰‡ç´¢å¼•
    const startGroup = groups[startGroupIdx];
    const endGroup = groups[endGroupIdx];
    
    return {
      startIndex: startGroup.itemStartIndex,
      endIndex: endGroup.itemStartIndex + endGroup.itemCount - 1,
      startOffset: startGroup.offset,
    };
  });
  
  /** å¯è§çš„æ—¥æœŸç»„ */
  const visibleGroups = computed<GroupLayout[]>(() => {
    const groups = layoutInfo.value.groups;
    const range = visibleRange.value;
    
    return groups.filter(g => {
      const groupEnd = g.itemStartIndex + g.itemCount - 1;
      return g.itemStartIndex <= range.endIndex && groupEnd >= range.startIndex;
    });
  });

  // ==================== æ–¹æ³• ====================
  
  /** åˆå§‹åŒ–ï¼šåŠ è½½å…ƒæ•°æ®å¹¶è®¡ç®—å¸ƒå±€ */
  async function initialize(): Promise<void> {
    isInitializing.value = true;
    error.value = null;
    
    try {
      // 1. åŠ è½½æ‰€æœ‰å…ƒæ•°æ®
      const meta = await invoke<ImageMeta[]>('get_all_metadata');
      allMeta.value = meta;
      
      // 2. è®¡ç®—å¸ƒå±€
      updateLayout();
      
      // 3. åŠ è½½é¦–å±è¯¦æƒ…
      await loadVisibleDetails();
      
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'åˆå§‹åŒ–å¤±è´¥';
      console.error('Timeline initialization failed:', e);
    } finally {
      isInitializing.value = false;
    }
  }
  
  /** æ›´æ–°å¸ƒå±€ï¼ˆå®¹å™¨å®½åº¦å˜åŒ–æ—¶è°ƒç”¨ï¼‰ */
  function updateLayout(): void {
    const container = containerRef.value;
    if (!container || allMeta.value.length === 0) return;
    
    layoutInfo.value = calculateLayout(allMeta.value, {
      containerWidth: container.clientWidth,
    });
    
    viewportHeight.value = container.clientHeight;
  }
  
  /** åŠ è½½å¯è§åŒºåŸŸçš„è¯¦æƒ… */
  async function loadVisibleDetails(): Promise<void> {
    const range = visibleRange.value;
    const meta = allMeta.value;
    
    if (meta.length === 0) return;
    
    // æ‰¾å‡ºéœ€è¦åŠ è½½çš„ ID
    const needLoad: string[] = [];
    
    for (let i = range.startIndex; i <= range.endIndex && i < meta.length; i++) {
      const id = meta[i].id;
      if (!detailCache.has(id)) {
        needLoad.push(id);
      }
    }
    
    if (needLoad.length === 0) {
      // å…¨éƒ¨å·²ç¼“å­˜ï¼Œç›´æ¥æ›´æ–°
      updateLoadedDetails();
      return;
    }
    
    isLoadingDetails.value = true;
    
    try {
      // åˆ†æ‰¹åŠ è½½
      for (let i = 0; i < needLoad.length; i += batchSize) {
        const batch = needLoad.slice(i, i + batchSize);
        const details = await invoke<ImageDetail[]>('get_details_by_ids', { ids: batch });
        
        // å­˜å…¥ç¼“å­˜
        details.forEach(d => detailCache.set(d.id, d));
      }
      
      // æ›´æ–°æ¸²æŸ“ç”¨çš„è¯¦æƒ…
      updateLoadedDetails();
      
    } catch (e) {
      console.error('Failed to load details:', e);
    } finally {
      isLoadingDetails.value = false;
    }
  }
  
  /** æ›´æ–°å·²åŠ è½½çš„è¯¦æƒ…ï¼ˆç”¨äºæ¸²æŸ“ï¼‰ */
  function updateLoadedDetails(): void {
    const range = visibleRange.value;
    const meta = allMeta.value;
    const newMap = new Map<string, ImageDetail>();
    
    for (let i = range.startIndex; i <= range.endIndex && i < meta.length; i++) {
      const id = meta[i].id;
      const detail = detailCache.get(id);
      if (detail) {
        newMap.set(id, detail);
      }
    }
    
    loadedDetails.value = newMap;
  }
  
  /** æ»šåŠ¨äº‹ä»¶å¤„ç† */
  let scrollRAF: number | null = null;
  let loadDebounce: number | null = null;
  
  function onScroll(e: Event): void {
    const target = e.target as HTMLElement;
    
    // ç«‹å³æ›´æ–°æ»šåŠ¨ä½ç½®ï¼ˆä¿è¯æ—¶é—´è½´åŒæ­¥ï¼‰
    scrollTop.value = target.scrollTop;
    
    // èŠ‚æµåŠ è½½è¯¦æƒ…
    if (loadDebounce) clearTimeout(loadDebounce);
    loadDebounce = window.setTimeout(() => {
      loadVisibleDetails();
    }, 100);
  }
  
  /** è·³è½¬åˆ°æŒ‡å®šæ—¥æœŸ */
  function scrollToDate(date: string, smooth = true): void {
    const offset = layoutInfo.value.dateOffsetMap.get(date);
    if (offset === undefined || !containerRef.value) return;
    
    containerRef.value.scrollTo({
      top: offset,
      behavior: smooth ? 'smooth' : 'auto',
    });
  }
  
  /** è·³è½¬åˆ°æŒ‡å®šä½ç½®ï¼ˆæ—¶é—´è½´æ»‘å—æ‹–åŠ¨æ—¶ï¼‰ */
  function scrollToPosition(percent: number): void {
    if (!containerRef.value) return;
    
    const targetTop = (percent / 100) * totalHeight.value;
    containerRef.value.scrollTop = targetTop;
  }
  
  /** è·å–æŒ‡å®šä½ç½®å¯¹åº”çš„æ—¥æœŸï¼ˆæ»‘å—æ‹–åŠ¨é¢„è§ˆï¼‰ */
  function getDateAtPosition(percent: number): string | null {
    const offset = (percent / 100) * totalHeight.value;
    const groups = layoutInfo.value.groups;
    
    for (let i = groups.length - 1; i >= 0; i--) {
      if (groups[i].offset <= offset) {
        return groups[i].date;
      }
    }
    
    return groups[0]?.date ?? null;
  }
  
  /** åˆ·æ–°æ•°æ®ï¼ˆä¸Šä¼ /åˆ é™¤åè°ƒç”¨ï¼‰ */
  async function refresh(): Promise<void> {
    detailCache.clear();
    loadedDetails.value = new Map();
    await initialize();
  }
  
  // ==================== ç›‘å¬ ====================
  
  // ç›‘å¬å®¹å™¨å¤§å°å˜åŒ–
  watch(containerRef, (container) => {
    if (container) {
      viewportHeight.value = container.clientHeight;
      
      const observer = new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        viewportHeight.value = height;
        
        // å®¹å™¨å®½åº¦å˜åŒ–æ—¶é‡æ–°è®¡ç®—å¸ƒå±€
        if (Math.abs(width - (layoutInfo.value as any)._containerWidth) > 10) {
          updateLayout();
        }
      });
      
      observer.observe(container);
    }
  }, { immediate: true });

  // ==================== è¿”å› ====================
  
  return {
    // çŠ¶æ€ï¼ˆåªè¯»ï¼‰
    allMeta: readonly(allMeta),
    isInitializing: readonly(isInitializing),
    isLoadingDetails: readonly(isLoadingDetails),
    error: readonly(error),
    
    // å¸ƒå±€
    totalHeight,
    visibleGroups,
    visibleRange,
    
    // æ»šåŠ¨çŠ¶æ€ï¼ˆä» scrollTop æ´¾ç”Ÿï¼Œä¿è¯åŒæ­¥ï¼‰
    scrollTop: readonly(scrollTop),
    currentDate,
    currentDateLabel,
    scrubberPosition,
    
    // æ•°æ®
    loadedDetails: readonly(loadedDetails),
    
    // æ–¹æ³•
    initialize,
    onScroll,
    scrollToDate,
    scrollToPosition,
    getDateAtPosition,
    refresh,
  };
}
```

### 4.4 ä¸»è§†å›¾ç»„ä»¶

```vue
<!-- components/timeline/TimelineView.vue -->
<template>
  <div class="timeline-view">
    <!-- ç²˜æ€§æ—¥æœŸæ ‡é¢˜ -->
    <Transition name="fade">
      <div 
        v-if="showStickyHeader" 
        class="sticky-header"
      >
        {{ currentDateLabel }}
      </div>
    </Transition>

    <!-- æ»šåŠ¨å®¹å™¨ -->
    <div 
      ref="scrollContainer"
      class="scroll-container"
      @scroll="onScroll"
    >
      <!-- å†…å®¹å®¹å™¨ï¼ˆå›ºå®šé«˜åº¦ï¼‰ -->
      <div 
        class="scroll-content"
        :style="{ height: totalHeight + 'px' }"
      >
        <!-- å¯è§çª—å£ -->
        <div 
          class="visible-window"
          :style="{ transform: `translateY(${windowOffset}px)` }"
        >
          <div
            v-for="group in visibleGroups"
            :key="group.date"
            class="date-group"
          >
            <!-- æ—¥æœŸæ ‡é¢˜ -->
            <div class="date-header">
              <span class="date-label">{{ group.label }}</span>
              <span class="item-count">{{ group.itemCount }} å¼ </span>
            </div>
            
            <!-- å›¾ç‰‡ç½‘æ ¼ -->
            <div class="image-grid">
              <TimelineImage
                v-for="index in group.itemCount"
                :key="allMeta[group.itemStartIndex + index - 1]?.id"
                :meta="allMeta[group.itemStartIndex + index - 1]"
                :detail="getDetail(group.itemStartIndex + index - 1)"
              />
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- æ—¶é—´è½´æ»‘å— -->
    <TimelineScrubber
      :position="scrubberPosition"
      :groups="layoutGroups"
      @seek="handleScrubberSeek"
      @preview="handleScrubberPreview"
    />

    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-if="isInitializing" class="loading-overlay">
      <div class="spinner"></div>
      <span>åŠ è½½ä¸­...</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useVirtualTimeline } from '@/composables/useVirtualTimeline';
import TimelineImage from './TimelineImage.vue';
import TimelineScrubber from './TimelineScrubber.vue';

const scrollContainer = ref<HTMLElement | null>(null);

const {
  allMeta,
  isInitializing,
  totalHeight,
  visibleGroups,
  visibleRange,
  scrollTop,
  currentDateLabel,
  scrubberPosition,
  loadedDetails,
  initialize,
  onScroll,
  scrollToDate,
  scrollToPosition,
  getDateAtPosition,
} = useVirtualTimeline(scrollContainer);

// å¯è§çª—å£åç§»é‡
const windowOffset = computed(() => {
  if (visibleGroups.value.length === 0) return 0;
  return visibleGroups.value[0].offset;
});

// æ˜¯å¦æ˜¾ç¤ºç²˜æ€§æ ‡é¢˜
const showStickyHeader = computed(() => scrollTop.value > 60);

// è·å–å›¾ç‰‡è¯¦æƒ…
function getDetail(index: number) {
  const id = allMeta.value[index]?.id;
  return id ? loadedDetails.value.get(id) : undefined;
}

// æ»‘å—è·³è½¬
function handleScrubberSeek(percent: number) {
  scrollToPosition(percent);
}

// æ»‘å—é¢„è§ˆ
function handleScrubberPreview(percent: number) {
  return getDateAtPosition(percent);
}

// å¸ƒå±€ç»„ï¼ˆç”¨äºæ»‘å—ï¼‰
const layoutGroups = computed(() => visibleGroups.value);

onMounted(() => {
  initialize();
});
</script>

<style scoped lang="scss">
.timeline-view {
  position: relative;
  height: 100%;
  overflow: hidden;
}

.sticky-header {
  position: absolute;
  top: 0;
  left: 0;
  right: 48px; // ç»™æ»‘å—ç•™ç©ºé—´
  z-index: 100;
  padding: 12px 16px;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border-color);
  font-weight: 600;
  font-size: 14px;
}

.scroll-container {
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
}

.scroll-content {
  position: relative;
}

.visible-window {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.date-group {
  padding: 0 16px;
}

.date-header {
  display: flex;
  align-items: baseline;
  gap: 8px;
  padding: 16px 0 12px;
  
  .date-label {
    font-weight: 600;
    font-size: 14px;
  }
  
  .item-count {
    font-size: 12px;
    color: var(--text-secondary);
  }
}

.image-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 4px;
}

.loading-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  background: var(--bg-primary);
  z-index: 200;
}

.spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--border-color);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.15s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

---

## äº”ã€æ—¶é—´è½´å¹´ä»½æ ‡è®°

### 5.1 è®¾è®¡è¯´æ˜

```
æ—¶é—´è½´æ»‘å—è®¾è®¡ï¼ˆç±»ä¼¼ Google ç›¸å†Œï¼‰ï¼š

                                    â”Œâ”€â”€â”€â”€â”€â”
                                    â”‚2025 â”‚ â† å¹´ä»½æ ‡è®°
                                    â”œâ”€â”€â”€â”€â”€â”¤
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â”œâ”€â”€â”€â”€â”€â”¤
                                    â”‚2024 â”‚ â† å¹´ä»½æ ‡è®°
                                    â”œâ”€â”€â”€â”€â”€â”¤
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â”‚  â—  â”‚ â† å½“å‰ä½ç½®ï¼ˆå¤§åœ†ç‚¹ï¼‰
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â”œâ”€â”€â”€â”€â”€â”¤
                                    â”‚2023 â”‚ â† å¹´ä»½æ ‡è®°
                                    â”œâ”€â”€â”€â”€â”€â”¤
                                    â”‚  â€¢  â”‚
                                    â”‚  â€¢  â”‚
                                    â””â”€â”€â”€â”€â”€â”˜

äº¤äº’ï¼š
- ç‚¹å‡»å¹´ä»½æ ‡è®° â†’ è·³è½¬åˆ°è¯¥å¹´ç¬¬ä¸€å¼ å›¾ç‰‡
- æ‹–åŠ¨æ»‘å—æ—¶ â†’ æ˜¾ç¤ºå½“å‰æ—¥æœŸé¢„è§ˆæ°”æ³¡
- æ‚¬åœå¹´ä»½ â†’ é«˜äº®æ˜¾ç¤º
```

### 5.2 ç±»å‹å®šä¹‰

```typescript
// types/timeline.ts è¿½åŠ 

/** å¹´ä»½æ ‡è®° */
export interface YearMark {
  year: number;
  position: number;      // åœ¨æ—¶é—´è½´ä¸Šçš„ä½ç½®ç™¾åˆ†æ¯” 0-100
  offset: number;        // å¯¹åº”çš„ scrollTop
  imageCount: number;    // è¯¥å¹´å›¾ç‰‡æ•°é‡
  firstDate: string;     // è¯¥å¹´ç¬¬ä¸€ä¸ªæ—¥æœŸ
}

/** æœˆä»½æ ‡è®°ï¼ˆå¯é€‰ï¼Œæ•°æ®é‡å¤§æ—¶æ˜¾ç¤ºï¼‰ */
export interface MonthMark {
  year: number;
  month: number;
  position: number;
  offset: number;
}
```

### 5.3 è®¡ç®—å¹´ä»½æ ‡è®°

```typescript
// utils/scrubberMarks.ts

import type { GroupLayout, YearMark, MonthMark } from '@/types/timeline';

/**
 * ä»æ—¥æœŸç»„ç”Ÿæˆå¹´ä»½æ ‡è®°
 */
export function generateYearMarks(
  groups: GroupLayout[],
  totalHeight: number
): YearMark[] {
  if (groups.length === 0 || totalHeight === 0) return [];
  
  const yearMap = new Map<number, {
    firstOffset: number;
    firstDate: string;
    count: number;
  }>();
  
  // éå†æ‰€æœ‰æ—¥æœŸç»„ï¼Œæ”¶é›†æ¯å¹´çš„ä¿¡æ¯
  groups.forEach(group => {
    const year = new Date(group.date).getFullYear();
    
    if (!yearMap.has(year)) {
      yearMap.set(year, {
        firstOffset: group.offset,
        firstDate: group.date,
        count: group.itemCount,
      });
    } else {
      yearMap.get(year)!.count += group.itemCount;
    }
  });
  
  // è½¬æ¢ä¸ºæ•°ç»„å¹¶è®¡ç®—ä½ç½®
  const marks: YearMark[] = [];
  
  yearMap.forEach((info, year) => {
    marks.push({
      year,
      position: (info.firstOffset / totalHeight) * 100,
      offset: info.firstOffset,
      imageCount: info.count,
      firstDate: info.firstDate,
    });
  });
  
  // æŒ‰å¹´ä»½é™åºæ’åˆ—ï¼ˆæœ€æ–°çš„åœ¨ä¸Šé¢ï¼‰
  return marks.sort((a, b) => b.year - a.year);
}

/**
 * ç”Ÿæˆæœˆä»½æ ‡è®°ï¼ˆå¯é€‰ï¼Œç”¨äºæ•°æ®é‡å¾ˆå¤§æ—¶ï¼‰
 */
export function generateMonthMarks(
  groups: GroupLayout[],
  totalHeight: number,
  minGap: number = 5  // æœ€å°é—´éš”ç™¾åˆ†æ¯”
): MonthMark[] {
  if (groups.length === 0 || totalHeight === 0) return [];
  
  const marks: MonthMark[] = [];
  let lastPosition = -minGap;
  
  const monthMap = new Map<string, { offset: number }>();
  
  groups.forEach(group => {
    const date = new Date(group.date);
    const key = `${date.getFullYear()}-${date.getMonth() + 1}`;
    
    if (!monthMap.has(key)) {
      monthMap.set(key, { offset: group.offset });
    }
  });
  
  monthMap.forEach((info, key) => {
    const [year, month] = key.split('-').map(Number);
    const position = (info.offset / totalHeight) * 100;
    
    // ç¡®ä¿æ ‡è®°ä¹‹é—´æœ‰è¶³å¤Ÿé—´éš”
    if (position - lastPosition >= minGap) {
      marks.push({ year, month, position, offset: info.offset });
      lastPosition = position;
    }
  });
  
  return marks.sort((a, b) => {
    if (a.year !== b.year) return b.year - a.year;
    return b.month - a.month;
  });
}
```

### 5.4 æ—¶é—´è½´æ»‘å—ç»„ä»¶

```vue
<!-- components/timeline/TimelineScrubber.vue -->
<template>
  <div 
    class="timeline-scrubber"
    ref="scrubberRef"
    @mousedown="startDrag"
    @touchstart.passive="startDrag"
  >
    <!-- è½¨é“ -->
    <div class="scrubber-track">
      <!-- å¹´ä»½æ ‡è®° -->
      <div
        v-for="mark in yearMarks"
        :key="mark.year"
        class="year-mark"
        :class="{ active: isYearActive(mark.year) }"
        :style="{ top: mark.position + '%' }"
        @click.stop="onYearClick(mark)"
      >
        <span class="year-label">{{ mark.year }}</span>
        <span class="year-dot"></span>
      </div>
      
      <!-- æœˆä»½å°åœ†ç‚¹ï¼ˆå¯é€‰ï¼‰ -->
      <div
        v-for="(dot, index) in monthDots"
        :key="`dot-${index}`"
        class="month-dot"
        :style="{ top: dot.position + '%' }"
      ></div>
      
      <!-- å½“å‰ä½ç½®æŒ‡ç¤ºå™¨ -->
      <div 
        class="current-indicator"
        :style="{ top: currentPosition + '%' }"
      >
        <div class="indicator-dot"></div>
      </div>
    </div>
    
    <!-- æ‹–åŠ¨æ—¶çš„æ—¥æœŸé¢„è§ˆ -->
    <Transition name="fade">
      <div 
        v-if="isDragging && previewLabel"
        class="drag-preview"
        :style="{ top: dragPosition + '%' }"
      >
        {{ previewLabel }}
      </div>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onUnmounted } from 'vue';
import type { YearMark, GroupLayout } from '@/types/timeline';
import { generateYearMarks } from '@/utils/scrubberMarks';

const props = defineProps<{
  position: number;              // å½“å‰ä½ç½® 0-100
  groups: GroupLayout[];         // æ‰€æœ‰æ—¥æœŸç»„
  totalHeight: number;           // æ€»é«˜åº¦
  currentYear?: number;          // å½“å‰å¹´ä»½
}>();

const emit = defineEmits<{
  seek: [offset: number];        // è·³è½¬åˆ°æŒ‡å®š offset
  yearClick: [year: number, offset: number];  // ç‚¹å‡»å¹´ä»½
}>();

const scrubberRef = ref<HTMLElement | null>(null);
const isDragging = ref(false);
const dragPosition = ref(0);
const previewLabel = ref('');

// å½“å‰ä½ç½®
const currentPosition = computed(() => props.position);

// å¹´ä»½æ ‡è®°
const yearMarks = computed(() => 
  generateYearMarks(props.groups, props.totalHeight)
);

// æœˆä»½å°åœ†ç‚¹ï¼ˆåœ¨å¹´ä»½ä¹‹é—´å‡åŒ€åˆ†å¸ƒï¼‰
const monthDots = computed(() => {
  const dots: { position: number }[] = [];
  const marks = yearMarks.value;
  
  for (let i = 0; i < marks.length - 1; i++) {
    const start = marks[i].position;
    const end = marks[i + 1].position;
    const gap = end - start;
    
    // æ¯ 3% æ”¾ä¸€ä¸ªç‚¹ï¼Œä½†ä¸è¦å¤ªå¯†
    const count = Math.min(Math.floor(gap / 3), 8);
    
    for (let j = 1; j <= count; j++) {
      dots.push({
        position: start + (gap * j) / (count + 1)
      });
    }
  }
  
  return dots;
});

// åˆ¤æ–­å¹´ä»½æ˜¯å¦é«˜äº®
function isYearActive(year: number): boolean {
  return year === props.currentYear;
}

// ç‚¹å‡»å¹´ä»½
function onYearClick(mark: YearMark) {
  emit('yearClick', mark.year, mark.offset);
}

// å¼€å§‹æ‹–åŠ¨
function startDrag(e: MouseEvent | TouchEvent) {
  isDragging.value = true;
  updateDragPosition(e);
  
  window.addEventListener('mousemove', onDrag);
  window.addEventListener('mouseup', endDrag);
  window.addEventListener('touchmove', onDrag, { passive: true });
  window.addEventListener('touchend', endDrag);
}

// æ‹–åŠ¨ä¸­
function onDrag(e: MouseEvent | TouchEvent) {
  if (!isDragging.value) return;
  updateDragPosition(e);
}

// æ›´æ–°æ‹–åŠ¨ä½ç½®
function updateDragPosition(e: MouseEvent | TouchEvent) {
  if (!scrubberRef.value) return;
  
  const rect = scrubberRef.value.getBoundingClientRect();
  const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
  const position = Math.max(0, Math.min(100,
    ((clientY - rect.top) / rect.height) * 100
  ));
  
  dragPosition.value = position;
  
  // è®¡ç®—å¯¹åº”çš„æ—¥æœŸç”¨äºé¢„è§ˆ
  const targetOffset = (position / 100) * props.totalHeight;
  const group = findGroupAtOffset(targetOffset);
  
  if (group) {
    previewLabel.value = group.label;
  }
}

// æ‰¾åˆ°æŒ‡å®š offset å¯¹åº”çš„æ—¥æœŸç»„
function findGroupAtOffset(offset: number): GroupLayout | null {
  const groups = props.groups;
  
  for (let i = groups.length - 1; i >= 0; i--) {
    if (groups[i].offset <= offset) {
      return groups[i];
    }
  }
  
  return groups[0] ?? null;
}

// ç»“æŸæ‹–åŠ¨
function endDrag() {
  if (isDragging.value) {
    // è·³è½¬åˆ°ç›®æ ‡ä½ç½®
    const targetOffset = (dragPosition.value / 100) * props.totalHeight;
    emit('seek', targetOffset);
  }
  
  isDragging.value = false;
  previewLabel.value = '';
  
  window.removeEventListener('mousemove', onDrag);
  window.removeEventListener('mouseup', endDrag);
  window.removeEventListener('touchmove', onDrag);
  window.removeEventListener('touchend', endDrag);
}

onUnmounted(() => {
  window.removeEventListener('mousemove', onDrag);
  window.removeEventListener('mouseup', endDrag);
  window.removeEventListener('touchmove', onDrag);
  window.removeEventListener('touchend', endDrag);
});
</script>

<style scoped lang="scss">
.timeline-scrubber {
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 48px;
  display: flex;
  justify-content: center;
  padding: 16px 0;
  user-select: none;
  z-index: 50;
}

.scrubber-track {
  position: relative;
  width: 2px;
  height: 100%;
  background: var(--border-color);
  border-radius: 1px;
}

// å¹´ä»½æ ‡è®°
.year-mark {
  position: absolute;
  right: 8px;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.15s ease;
  
  &:hover {
    .year-label {
      color: var(--primary-color);
    }
    .year-dot {
      background: var(--primary-color);
      transform: scale(1.3);
    }
  }
  
  &.active {
    .year-label {
      color: var(--primary-color);
      font-weight: 600;
    }
    .year-dot {
      background: var(--primary-color);
    }
  }
}

.year-label {
  font-size: 11px;
  font-weight: 500;
  color: var(--text-secondary);
  white-space: nowrap;
  transition: color 0.15s ease;
}

.year-dot {
  width: 6px;
  height: 6px;
  background: var(--text-tertiary);
  border-radius: 50%;
  transition: all 0.15s ease;
}

// æœˆä»½å°åœ†ç‚¹
.month-dot {
  position: absolute;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 4px;
  height: 4px;
  background: var(--border-color);
  border-radius: 50%;
}

// å½“å‰ä½ç½®æŒ‡ç¤ºå™¨
.current-indicator {
  position: absolute;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10;
  
  .indicator-dot {
    width: 12px;
    height: 12px;
    background: var(--primary-color);
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(var(--primary-rgb), 0.4);
    transition: transform 0.1s ease;
  }
  
  &:hover .indicator-dot {
    transform: scale(1.2);
  }
}

// æ‹–åŠ¨é¢„è§ˆæ°”æ³¡
.drag-preview {
  position: absolute;
  right: 56px;
  transform: translateY(-50%);
  padding: 6px 12px;
  background: var(--bg-elevated);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  font-size: 13px;
  font-weight: 500;
  white-space: nowrap;
  pointer-events: none;
  
  // å°ç®­å¤´
  &::after {
    content: '';
    position: absolute;
    right: -6px;
    top: 50%;
    transform: translateY(-50%);
    border: 6px solid transparent;
    border-left-color: var(--bg-elevated);
  }
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.15s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

### 5.5 åœ¨ Composable ä¸­æ·»åŠ å½“å‰å¹´ä»½

```typescript
// composables/useVirtualTimeline.ts è¿½åŠ 

/** å½“å‰å¹´ä»½ï¼ˆä» currentDate æ´¾ç”Ÿï¼‰ */
const currentYear = computed(() => {
  const date = currentDate.value;
  if (!date) return null;
  return new Date(date).getFullYear();
});

// åœ¨ return ä¸­æ·»åŠ 
return {
  // ... å…¶ä»–
  currentYear,
};
```

### 5.6 æ›´æ–°ä¸»è§†å›¾ç»„ä»¶

```vue
<!-- åœ¨ TimelineView.vue ä¸­æ›´æ–° TimelineScrubber çš„ä½¿ç”¨ -->
<TimelineScrubber
  :position="scrubberPosition"
  :groups="allGroups"
  :total-height="totalHeight"
  :current-year="currentYear"
  @seek="handleScrubberSeek"
  @year-click="handleYearClick"
/>

<script setup>
// æ·»åŠ å¹´ä»½ç‚¹å‡»å¤„ç†
function handleYearClick(year: number, offset: number) {
  scrollContainer.value?.scrollTo({
    top: offset,
    behavior: 'smooth'
  });
}

// æ»‘å—æ‹–åŠ¨è·³è½¬
function handleScrubberSeek(offset: number) {
  scrollContainer.value?.scrollTo({
    top: offset,
    behavior: 'auto'  // æ‹–åŠ¨æ—¶ä¸ç”¨åŠ¨ç”»
  });
}
</script>
```

### 5.7 æ•ˆæœé¢„è§ˆ

```
ä¼˜åŒ–åçš„æ—¶é—´è½´æ•ˆæœï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸Šä¼ å†å²    âŠ ğŸ“…    å…¨éƒ¨å›¾åºŠ â–¼    ğŸ” æœç´¢...   33002â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”                              2025 â”€â—  â”‚ â† å¹´ä»½æ ‡è®°
â”‚  â”‚ å›¾1 â”‚ å›¾2 â”‚                                   â€¢  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜                                   â€¢  â”‚
â”‚                                                  â€¢  â”‚
â”‚  2023å¹´5æœˆ18æ—¥  15å¼ ç…§ç‰‡                    2024 â”€â—‹  â”‚ â† å¹´ä»½æ ‡è®°
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”                             â€¢  â”‚
â”‚  â”‚     â”‚     â”‚     â”‚                             â€¢  â”‚
â”‚  â”‚ å›¾3 â”‚ å›¾4 â”‚ å›¾5 â”‚                             â€¢  â”‚
â”‚  â”‚     â”‚     â”‚     â”‚                             â—  â”‚ â† å½“å‰ä½ç½®
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜                             â€¢  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”                                   â€¢  â”‚
â”‚  â”‚     â”‚     â”‚                             2023 â”€â—‹  â”‚ â† å¹´ä»½æ ‡è®°
â”‚  â”‚ å›¾6 â”‚ å›¾7 â”‚                                   â€¢  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜                                   â€¢  â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

äº¤äº’è¯´æ˜ï¼š
â€¢ ç‚¹å‡»å¹´ä»½æ ‡è®° â†’ ç›´æ¥è·³è½¬åˆ°è¯¥å¹´ç¬¬ä¸€å¼ å›¾ç‰‡
â€¢ æ‹–åŠ¨è“è‰²åœ†ç‚¹ â†’ æ˜¾ç¤ºé¢„è§ˆæ°”æ³¡ï¼Œæ¾å¼€åè·³è½¬
â€¢ å½“å‰å¹´ä»½é«˜äº®æ˜¾ç¤º
```

---

## å…­ã€é—®é¢˜è§£å†³éªŒè¯

### 5.1 éªŒè¯ï¼šå‘ä¸Šæ»šåŠ¨æ­£å¸¸

```
ä¸ºä»€ä¹ˆç°åœ¨å¯ä»¥æ­£å¸¸å‘ä¸Šæ»šåŠ¨ï¼š

1. æ€»é«˜åº¦æ’å®š
   - totalHeight åœ¨åˆå§‹åŒ–æ—¶è®¡ç®—ï¼Œå§‹ç»ˆæ­£ç¡®
   - æ»šåŠ¨å®¹å™¨æœ‰å®Œæ•´çš„é«˜åº¦ç©ºé—´

2. è·³è½¬åªæ”¹ scrollTop
   scrollToDate('2024-03-15')
      â†“
   æ‰¾åˆ° offset = 5000px
      â†“
   container.scrollTop = 5000
      â†“
   ä¸Šæ–¹æœ‰ 5000px ç©ºé—´å¯ä»¥å‘ä¸Šæ»šåŠ¨ âœ“

3. å¯è§çª—å£ç”¨ transform å®šä½
   - ä¸å½±å“æ»šåŠ¨å®¹å™¨çš„æ»šåŠ¨èŒƒå›´
   - åªæ¸²æŸ“å¯è§å†…å®¹ï¼Œæ€§èƒ½å¥½
```

### 5.2 éªŒè¯ï¼šæ—¶é—´è½´åŒæ­¥

```
ä¸ºä»€ä¹ˆç°åœ¨ä¿æŒåŒæ­¥ï¼š

å•ä¸€æ•°æ®æºï¼šscrollTop
     â†“
     â”œâ”€â†’ currentDateï¼ˆäºŒåˆ†æŸ¥æ‰¾ï¼‰
     â”œâ”€â†’ scrubberPositionï¼ˆç™¾åˆ†æ¯”è®¡ç®—ï¼‰
     â””â”€â†’ visibleRangeï¼ˆèŒƒå›´è®¡ç®—ï¼‰

æ‰€æœ‰çŠ¶æ€éƒ½ä» scrollTop æ´¾ç”Ÿï¼š
- æ— è®ºæ˜¯ç”¨æˆ·æ»šåŠ¨è¿˜æ˜¯è·³è½¬
- æ— è®ºæ˜¯æ‹–åŠ¨æ»‘å—è¿˜æ˜¯ç‚¹å‡»æ—¥æœŸ
- æœ€ç»ˆéƒ½æ˜¯ä¿®æ”¹ scrollTop
- å…¶ä»–çŠ¶æ€è‡ªåŠ¨åŒæ­¥æ›´æ–°
```

---

## å…­ã€æ•°æ®åŒæ­¥å¤„ç†

### 6.1 ä¸Šä¼ æ–°å›¾ç‰‡å

```typescript
// åœ¨ä¸Šä¼ æˆåŠŸåè°ƒç”¨
async function onUploadSuccess(newImage: ImageDetail) {
  // 1. æ’å…¥åˆ°å…ƒæ•°æ®åˆ—è¡¨å¤´éƒ¨ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
  allMeta.value.unshift({
    id: newImage.id,
    uploadTime: newImage.uploadTime,
    width: newImage.width,
    height: newImage.height,
  });
  
  // 2. å­˜å…¥ç¼“å­˜
  detailCache.set(newImage.id, newImage);
  
  // 3. é‡æ–°è®¡ç®—å¸ƒå±€
  updateLayout();
  
  // 4. æ›´æ–°å¯è§è¯¦æƒ…
  updateLoadedDetails();
}
```

### 6.2 åˆ é™¤å›¾ç‰‡å

```typescript
// åœ¨åˆ é™¤æˆåŠŸåè°ƒç”¨
function onDeleteSuccess(deletedIds: string[]) {
  const idSet = new Set(deletedIds);
  
  // 1. ä»å…ƒæ•°æ®ä¸­ç§»é™¤
  allMeta.value = allMeta.value.filter(m => !idSet.has(m.id));
  
  // 2. ä»ç¼“å­˜ä¸­ç§»é™¤
  deletedIds.forEach(id => detailCache.delete(id));
  
  // 3. é‡æ–°è®¡ç®—å¸ƒå±€
  updateLayout();
  
  // 4. æ›´æ–°å¯è§è¯¦æƒ…
  updateLoadedDetails();
}
```

### 6.3 å¯¼å…¥å†å²è®°å½•å

```typescript
// åœ¨å¯¼å…¥æˆåŠŸåè°ƒç”¨
async function onImportSuccess() {
  // å®Œå…¨åˆ·æ–°
  await refresh();
}
```

---

## ä¸ƒã€æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å |
|------|--------|--------|
| é¦–å±åŠ è½½ | 2-3sï¼ˆåŠ è½½ 500 æ¡ï¼‰ | <200msï¼ˆå…ƒæ•°æ®ï¼‰ |
| å†…å­˜å ç”¨ | ~50MBï¼ˆ500 å›¾ç‰‡ DOMï¼‰ | ~10MBï¼ˆå¯è§åŒºåŸŸï¼‰ |
| è·³è½¬å“åº” | 500ms+ | <16msï¼ˆä¸€å¸§ï¼‰ |
| æ»šåŠ¨å¸§ç‡ | 30-40fps | 60fps |
| æ—¶é—´è½´åŒæ­¥ | å»¶è¿Ÿ 100-200ms | å®æ—¶ |

---

## å…«ã€æ³¨æ„äº‹é¡¹

1. **å¸ƒå±€é‡ç®—æ—¶æœº**
   - å…ƒæ•°æ®å˜åŒ–æ—¶
   - å®¹å™¨å®½åº¦å˜åŒ–æ—¶
   - ä¸è¦åœ¨æ»šåŠ¨æ—¶é‡ç®—

2. **è¯¦æƒ…åŠ è½½èŠ‚æµ**
   - æ»šåŠ¨åœæ­¢ 100ms åå†åŠ è½½
   - é¿å…å¿«é€Ÿæ»šåŠ¨æ—¶å¤§é‡è¯·æ±‚

3. **ç¼“å­˜ç­–ç•¥**
   - LRU ç¼“å­˜ï¼Œä¿ç•™æœ€è¿‘è®¿é—®çš„ 500 æ¡
   - è·³è½¬æ—¶ä¼˜å…ˆåŠ è½½ç›®æ ‡åŒºåŸŸ

4. **å“åº”å¼é€‚é…**
   - ç›‘å¬å®¹å™¨ resize
   - å®½åº¦å˜åŒ–æ—¶é‡ç®—å¸ƒå±€
   - é«˜åº¦å˜åŒ–æ—¶æ›´æ–° viewportHeight
